<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>scikit-learn系列七：朴素贝叶斯</title>
      <link href="/2020/07/02/scikit-learn-xi-lie-qi-po-su-bei-xie-si/"/>
      <url>/2020/07/02/scikit-learn-xi-lie-qi-po-su-bei-xie-si/</url>
      
        <content type="html"><![CDATA[<h2 id="项目地址传送门，欢迎-star-和-fork-！"><a href="#项目地址传送门，欢迎-star-和-fork-！" class="headerlink" title="项目地址传送门，欢迎 star 和 fork ！"></a>项目地址<a href="https://github.com/DongZhouGu/scikit-learn-ml" target="_blank" rel="noopener">传送门</a>，欢迎 star 和 fork ！</h2><h2 id="1-朴素贝叶斯概述"><a href="#1-朴素贝叶斯概述" class="headerlink" title="1. 朴素贝叶斯概述"></a>1. 朴素贝叶斯概述</h2><p>贝叶斯分类是一类分类算法的总称，这类算法均以贝叶斯定理为基础，故统称为贝叶斯分类。朴素贝叶斯（Naive Bayers）算法是一种基于概率统计的分类方法。它在条件独立假设的基础上，使用贝叶斯定理构建算法，在文本处理领域有广泛的应用。</p><h2 id="2-贝叶斯理论-amp-条件概率"><a href="#2-贝叶斯理论-amp-条件概率" class="headerlink" title="2. 贝叶斯理论 &amp; 条件概率"></a>2. 贝叶斯理论 &amp; 条件概率</h2><h3 id="2-1-贝叶斯理论"><a href="#2-1-贝叶斯理论" class="headerlink" title="2.1 贝叶斯理论"></a>2.1 贝叶斯理论</h3><p>我们现在有一个数据集，它由两类数据组成，数据分布如下图所示: </p><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%A4%BA%E4%BE%8B%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83.png" alt="朴素贝叶斯示例数据分布" title="参数已知的概率分布"></p><p>我们现在用 p1(x,y) 表示数据点 (x,y) 属于类别 1（图中用圆点表示的类别）的概率，用 p2(x,y) 表示数据点 (x,y) 属于类别 2（图中三角形表示的类别）的概率，那么对于一个新数据点 (x,y)，可以用下面的规则来判断它的类别: </p><ul><li>如果 p1(x,y) &gt; p2(x,y) ，那么类别为1</li><li>如果 p2(x,y) &gt; p1(x,y) ，那么类别为2</li></ul><p>也就是说，我们会选择高概率对应的类别。这就是贝叶斯决策理论的核心思想，即选择具有最高概率的决策。</p><h3 id="2-2-条件概率"><a href="#2-2-条件概率" class="headerlink" title="2.2 条件概率"></a>2.2 条件概率</h3><p>如果你对 p(x,y|c1) 符号很熟悉，那么可以跳过本小节。</p><p>有一个装了 7 块石头的罐子，其中 3 块是白色的，4 块是黑色的。如果从罐子中随机取出一块石头，那么是白色石头的可能性是多少？由于取石头有 7 种可能，其中 3 种为白色，所以取出白色石头的概率为 3/7 。那么取到黑色石头的概率又是多少呢？很显然，是 4/7 。我们使用 P(white) 来表示取到白色石头的概率，其概率值可以通过白色石头数目除以总的石头数目来得到。</p><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/NB_2.png" alt="包含 7 块石头的集合"></p><p>如果这 7 块石头如下图所示，放在两个桶中，那么上述概率应该如何计算？</p><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/NB_5.png" alt="7块石头放入两个桶中"></p><p>计算 P(white) 或者 P(black) ，如果事先我们知道石头所在桶的信息是会改变结果的。这就是所谓的条件概率（conditional probablity）。假定计算的是从 B 桶取到白色石头的概率，这个概率可以记作 P(white|bucketB) ，我们称之为“在已知石头出自 B 桶的条件下，取出白色石头的概率”。很容易得到，P(white|bucketA) 值为 2/4 ，P(white|bucketB) 的值为 1/3 。</p><p>条件概率的计算公式如下: </p><p>P(white|bucketB) = P(white and bucketB) / P(bucketB)</p><p>首先，我们用 B 桶中白色石头的个数除以两个桶中总的石头数，得到 P(white and bucketB) = 1/7 .其次，由于 B 桶中有 3 块石头，而总石头数为 7 ，于是 P(bucketB) 就等于 3/7 。于是又 P(white|bucketB) = P(white and bucketB) / P(bucketB) = (1/7) / (3/7) = 1/3 。</p><p>另外一种有效计算条件概率的方法称为贝叶斯准则。贝叶斯准则告诉我们如何交换条件概率中的条件与结果，即如果已知 P(x|c)，要求 P(c|x)，那么可以使用下面的计算方法: </p><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/NB_3.png" alt="计算p(c|x)的方法"></p><h3 id="2-3-使用条件概率来分类"><a href="#2-3-使用条件概率来分类" class="headerlink" title="2.3 使用条件概率来分类"></a>2.3 使用条件概率来分类</h3><p>上面我们提到贝叶斯决策理论要求计算两个概率 p1(x, y) 和 p2(x, y):</p><ul><li>如果 p1(x, y) &gt; p2(x, y), 那么属于类别 1;</li><li>如果 p2(x, y) &gt; p1(X, y), 那么属于类别 2.</li></ul><p>这并不是贝叶斯决策理论的所有内容。使用 p1() 和 p2() 只是为了尽可能简化描述，而真正需要计算和比较的是 p(c1|x, y) 和 p(c2|x, y) .这些符号所代表的具体意义是: 给定某个由 x、y 表示的数据点，那么该数据点来自类别 c1 的概率是多少？数据点来自类别 c2 的概率又是多少？注意这些概率与概率 p(x, y|c1) 并不一样，不过可以使用贝叶斯准则来交换概率中条件与结果。具体地，应用贝叶斯准则得到: </p><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/NB_4.png" alt="应用贝叶斯准则"></p><p>使用上面这些定义，可以定义贝叶斯分类准则为:</p><ul><li>如果 P(c1|x, y) &gt; P(c2|x, y), 那么属于类别 c1;</li><li>如果 P(c2|x, y) &gt; P(c1|x, y), 那么属于类别 c2.</li></ul><p>在文档分类中，整个文档（如一封电子邮件）是实例，而电子邮件中的某些元素则构成特征。我们可以观察文档中出现的词，并把每个词作为一个特征，而每个词的出现或者不出现作为该特征的值，这样得到的特征数目就会跟词汇表中的词的数目一样多。</p><p>我们假设特征之间  <strong>相互独立</strong> 。所谓 <b>独立(independence)</b> 指的是统计意义上的独立，即一个特征或者单词出现的可能性与它和其他单词相邻没有关系，比如说，“我们”中的“我”和“们”出现的概率与这两个字相邻没有任何关系。这个假设正是朴素贝叶斯分类器中 朴素(naive) 一词的含义。朴素贝叶斯分类器中的另一个假设是，<b>每个特征同等重要</b>。</p><blockquote><p><b>Note:</b> 朴素贝叶斯分类器通常有两种实现方式: 一种基于伯努利模型实现，一种基于多项式模型实现。前者中并不考虑词在文档中出现的次数，只考虑出不出现，因此在这个意义上相当于假设词是等权重的。</p></blockquote><h2 id="3-一个简单的例子"><a href="#3-一个简单的例子" class="headerlink" title="3. 一个简单的例子"></a>3. 一个简单的例子</h2><p>我们先通过一个简单的例子，来看怎样应用朴素贝叶斯分类算法。假设有以下关于驾龄、平均车速和性别的统计数据：</p><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/17634123-28f863c2b8a241e7.png" alt="img"></p><blockquote><p>现在观察到一个驾龄为2年的人，平均车速为80。问：这个人的性别是什么？</p></blockquote><p>假设 $C_{0}$ 表示女  $C_{1}$ 表示男，$x_{0}$ 表示驾龄，$x_{1}$ 表示平均车速。我们先来计算这个人为女性的概率相对值。根据统计数据，女性司机的概率 $P\left(C_{0}\right)=5 / 10=0.5$ ，。驾龄为2年的女性司机的概率即 $P\left(x_{0} \mid C_{0}\right)=1 / 5=0.2$ 。平均车速为80的女性司机的概率  $P\left(x_{1} \mid C_{0}\right)=1 / 5=0.2$，根据朴素贝叶斯分类算法的数学公式：</p><p>$$<br>P\left(C_{0}\right) \prod_{i=1}^{n} P\left(x_{i} \mid C_{0}\right)=0.5 \times 0.2 \times 0.2=0.02<br>$$<br>接着计算这个人为男性的概率相对值。根据统计数据，不难得出男性司机的概率 $P\left(C_{1}\right)=5 / 10=0.5$ 。驾龄为2年的男性司机的概率 $P\left(x_{0} \mid C_{1}\right)=2 / 5=0.4$ 。平均车速为80的男性司机的概率 $P\left(x_{1} \mid C_{1}\right)=3 / 5=0.6$<br>$$<br>P\left(C_{1}\right) \prod_{i=1}^{n} P\left(x_{i} \mid C_{1}\right)=0.5 \times 0.4 \times 0.6=0.12<br>$$<br>从相对概率来看，这个人是男性的概率是女性的概率的6倍，据此判断这个人是男性。我们也可以从相对概率中算出绝对概率，即这个人是男性的绝对概率是0.12/(0.12+0.02)=0.857。</p><h2 id="4-概率分布"><a href="#4-概率分布" class="headerlink" title="4.概率分布"></a>4.概率分布</h2><p>到目前为止，我们介绍的朴素贝叶斯分类算法是根据数据集里的数据，计算出绝对概率来进行求解。再看一遍朴素贝叶斯分类算法的数学公式：<br>$$<br>P\left(C_{k} \mid x\right) \propto P\left(C_{k}\right) \prod_{i=1}^{n} P\left(x_{i} \mid C_{k}\right)<br>$$<br>其中， $P\left(C_{k} \mid x\right) $表示在类别$C_{k}$ 里特征$x_{i}$ 出现的概率。这里有个最大的问题，如果数据集太小，那么从数据集里计算出来的概率偏差将非常严重。例如，观察一个质地均匀的骰子投掷6次的结果是[1,3,1,5,3,3]。质地均匀的骰子每个点出现的概率都是1/6，如果根据观察到的数据集去计算每个点的概率，和真实的概率相差将是非常大的。</p><p>怎么解决这个问题呢？答案是使用概率分布来计算概率，而不是从数据集里计算概率。</p><h3 id="4-1-概率统计的基本概念"><a href="#4-1-概率统计的基本概念" class="headerlink" title="4.1 概率统计的基本概念"></a>4.1 概率统计的基本概念</h3><p>人的身高是一个连续的随机变量，而投掷一个骰子得到的点数则是一个离散的随机变量。我们闭着眼睛随便找一个人，问这个人的身高是170cm的可能性是多大呢？如果有一个函数，能描述人类身高的可能性，那么直接把170cm代入即可求出这个可能性。这个函数就是概率密度函数，也称为<code>PDF（Probability Density Function）</code>。典型的概率密度函数是高斯分布函数，如人类的身高就满足高斯分布的规律。</p><p>再例如，投掷一个质地均匀的骰子，得到6的概率是多少呢？大家都知道答案是1/6。假如有一个函数f(x)，能描述骰子出现x点数的概率，那么把x代入即可得到概率，这个函数称为概率质量函数，即PMF（Probability Mass Function）。那么，为什么还有使用概率质量函数呢？一是在数学上追求统一性，二是并不是所有的离散随机变量的概率分布都像掷一次骰子这个直观。例如，投掷6次质地均匀的骰子，得到4个4的概率是多少？这个时候如果有概率质量函数，就可以轻松求解了。</p><blockquote><p>总结一下，随机变量分成两种，一种是连续随机变量，另外一种是离散随机变量。概率密度函数描述的是连续随机变量在某个特定值的可能性，概率质量函数描述的是离散随机变量在某个特定值的可能性。而概率分布则是描述随机变量取值的概率规律。</p></blockquote><h3 id="4-2-多项式分布"><a href="#4-2-多项式分布" class="headerlink" title="4.2 多项式分布"></a>4.2 多项式分布</h3><p> 抛一枚硬币，要么出现正面，要么出现反面（假设硬币不会立起来）。假如出现正面的概率是p，则出现反面的概率就是1-p。符合这个规律的概率分布，称为 <code>伯努利分布（Bernoulli Distribution）</code>。其概率质量函数为：<br>$$<br>f(k ; p)=p^{k}(1-p)^{1-k}<br>$$<br>p是出现1的概率。例如，一枚质地均匀的硬币被抛一次，得到正面的概率为0.5。我们代入上述公式，也可以得到相同的结果，即f(1;0.5)=0.5。</p><p>更一般的情况，即不止两种可能性时，假设每种可能性是$p_{i}$, 则满足  $\sum_{i}^{n} p_{i}=1$， 条件的概率分布，称为<code>类别分布（Categorical Distribution）</code>。例如，投掷一枚骰子，则会出现6中可能性，所有的可能性加起来的概率为1。类别分布的概率质量函数为：<br>$$<br>f(x \mid p)=\prod_{i=1}^{k} p_{i}^{x_{i}}<br>$$<br>那么，一枚质地均匀的硬币被抛10次，出现3次正面的概率是多少呢？这是个典型的二项式分布问题。二项式分布指的是把符号伯努利分布的实验做了n次，结果1出现0次、1次、2次……n次的概率分别是多少，它的概率质量函数为：<br>$$<br>f(k ; n, p)=C_{n}^{k} p^{k}(1-p)^{n-k}<br>$$<br>枚质地均匀的硬币被抛10次，出现3次正面的概率是多少？代入二项式分布的概率质量函数，得到：<br>$$<br>f(3 ; 10,0.5)=\frac{10 !}{3 ! \times(10-3) !} \times 0.5^{3} \times(1-0.5)^{10-3}=0.1171875<br>$$<br>其中，0的阶乘为1，即0!=1。结果跟我们预期的相符。当实验只做一次时，二项式分布退化为伯努利分布。</p><p>简单总结一下，二项式分布描述的是多次伯努利实验中，某个结果出现次数的概率。多项式分布描述的是多次进行满足类别分布的实验中，所有类别出现的次数组合的分布。</p><p>二项式分布和多项式分布结合朴素贝叶斯算法，经常被用来实现文章分类算法。例如，有一个论坛需要对用户的评论进行过滤，屏蔽不文明的评论。首先要有一个经过标记的数据集，我们称为语料库。假设使用人工标记的方法对评论进行标记，1表示不文明的评论，0表示正常评论。</p><p>假设我们的词库大小为 k ，则评论中出现某个词可以看成是一次满足k个类别的类别分布实验。我们知道，一篇评论是由n个词组成的，因此一篇评论可以看出是进行n次类别分布实验后的产物。由此得知，一篇评论服从多项式分布，它是词库里的所有词语出现的次数组合构成的随机向量。</p><p>一般情况下，词库比较大，评论只是由少量词组成，所以这个随机向量是很稀疏的，即大部分元素为0。通过分析预料库，我们容易统计出每个词出现在不文明评论及正常评论的概率，即 $p_{i}$的值。同时针对待预测的评论，我们可以统计词库里的所有词在这篇评论里出现的次数即  $x_{i}$ 的值，及评论的词语个数。代入多项式分布的概率质量函数：<br>$$<br>f(X, n, P)=\frac{n !}{\prod_{i=1}^{k} x_{i} !} \prod_{i=1}^{k} p_{i}^{x_{i}}<br>$$<br>我们可以求出，待预测评论构成的随机向量x，其为不文明评论的相对概率。同理也可以求出其为正常评论的相对概率。通过比较两个相对概率，就可以对这篇评论输出一个预测值。当然，实际应用中，涉及大量的自然语言处理的手段，包括中文分词技术、词的数学表示等，这里不再展开。</p><h3 id="4-3-高斯分布"><a href="#4-3-高斯分布" class="headerlink" title="4.3 高斯分布"></a>4.3 高斯分布</h3><p>在前面的车速和性别预测的例子里，对于平均车速，给出的是离散值，实际上它是一个连续值。这个时候怎么使用贝叶斯算法来处理呢？答案是，可以用区间把连续值转换成离散值。例如，我们可以把平均车速[0,40]作为一个级别，[40-80]，等等。这样就可以把连续值变成离散值，从而使用贝叶斯算法进行处理。另外一个方法，是使用连续随机变量的概率密度函数，把数值转换为一个相对概率。高斯分布就是这样一种方法。</p><p><code>高斯分布（Gaussian Distribution）</code>也称为 <code>正态分布（Normal Distribution）</code>，是最常见的一种分布。例如人的身高满足高斯分布，特别高和特别矮的人出现的相对概率都很低，大部分人身高都处在中间水平。还有人的智商也符合高斯分布，特别聪明的天才和特别笨的人出现的相对概率都很低，大部分人的智力都差不多。高斯分布的概率密度函数为：<br>$$<br>f(x)=\frac{1}{\sqrt{2 \pi \sigma^{2}}} \exp \left(-\frac{(x-\mu)^{2}}{2 \sigma^{2}}\right)<br>$$<br>其中，$x$ 为随机变量的值，$f(x)$ 为随机变量的相对概率，$\mu$为样本的平均值，其决定了高斯分布曲线的位置，<img src="/medias/loading.gif" data-original="https://math.jianshu.com/math?formula=%5Csigma" alt="\sigma">为标准差，其决定了高斯分布的幅度，$\sigma$ 值越大，分布越分散，<img src="/medias/loading.gif" data-original="https://math.jianshu.com/math?formula=%5Csigma" alt="\sigma">$\sigma$值越小，分布越集中。典型的高斯分布如下图所示：</p><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/17634123-e4f8952fc25052e3.png" alt="img"></p><p>这里需要注意的是：高斯分布的概率密度函数和支持向量机里的高斯核函数的区别。二者的核心数学模型是相同的，但是目的不同。</p><h3 id="4-4-连续值得处理"><a href="#4-4-连续值得处理" class="headerlink" title="4.4 连续值得处理"></a>4.4 连续值得处理</h3><p>假设，有一组身体特征的统计数据如下：</p><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/17634123-ab2a72e2cf69b3f1.png" alt="img"></p><p>假设某人身高6英尺，体重130榜，脚掌8英寸，请问此人的性别是什么？</p><p>根据朴素贝叶斯公式：<br>$$<br>P\left(C_{k} \mid x\right) \propto P\left(C_{k}\right) \prod_{i=1}^{n} P\left(x_{i} \mid C_{k}\right)<br>$$<br>针对待预测的这个人的数据$x$ ，我们只需要分别求出男性和女性的相对概率<br>$$<br>P(\text {Gender}) \times P(\text {Height} \mid \text {Gender}) \times P(\text {Weight} \mid \text {Gender}) \times P(\text {Feet} \mid \text {Gender})<br>$$<br>然后取相对概率较高的性别为预测值即可。这里的困难在于，所有的特征都是连续变量，无法根据统计数据计算概率。当然，这里我们可以使用区间法，把连续变量变为离散变量，然后再计算概率。但由于数据量较小，这显然不是一个好办法。由于人类身高、体重、脚掌尺寸满足高斯分布，因此更好的办法是使用高斯分布的概率密度函数来求相对概率。</p><p>首先，针对男性和女性，分别求出特征的平均值和方差：</p><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/17634123-4755f7b16509dc1d.png" alt="img"></p><p>接着利用高斯分布的概率密度函数，来求解男性身高为6英尺的相对概率：<br>$$<br>P(\text {Height}=6 \mid \text {Male})=\frac{1}{\sqrt{2 \pi \times 0.035033^{2}}} \exp \left(-\frac{(6-5.855)^{2}}{2 \times 0.035033^{2}}\right) \approx 1.5789<br>$$<br>这里的关键是把连续值（身高）作为输入，通过高斯分布的概率密度函数的处理，直接转换为相对概率。注意这里是相对概率，所以其值大于1并未违反概率论规则。</p><h2 id="5-示例：文档分类"><a href="#5-示例：文档分类" class="headerlink" title="5. 示例：文档分类"></a>5. 示例：文档分类</h2><p>在 <code>scikit-learn</code>里，朴素贝叶斯算法在 <code>sklearn.naive_bayes</code> 包里实现，包含本文介绍的几种典型的概率分布算法。其中 <code>GaussianNB</code> 实现了高斯分布的朴素贝叶斯算法，<code>MultinomialNB</code> 实现了多项式分布的朴素贝叶斯算法，<code>BernoulliNB</code>实现了伯努利分布的朴素贝叶斯算法。朴素贝叶斯算法在自然语言处理领域有着广泛的应用，这里我们使用 <code>MultinomialNB</code> 来实现文档的自动分类。</p><h3 id="5-1-获取数据集"><a href="#5-1-获取数据集" class="headerlink" title="5.1 获取数据集"></a>5.1 获取数据集</h3><p>这里使用的数据集来自 mlcomp.org上的20news-18828，可以直接访问<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fmlcomp.org%2Fdatasets%2F379" target="_blank" rel="noopener">http://mlcomp.org/datasets/379</a>下载。其目录下包含3个子目录和一个名为metadata的介绍文件，数据集也可在百度网盘下载。，已分享。</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1uQNkLWIN0niz8-p8BppRJg" target="_blank" rel="noopener">https://pan.baidu.com/s/1uQNkLWIN0niz8-p8BppRJg</a><br>提取码：bvhe<br>复制这段内容后打开百度网盘手机App，操作更方便哦</p></blockquote><p>我们将使用 <code>train</code> 子目录下的文档进行模型训练，然后使用 <code>test</code> 子目录下的文档进行模型测试。<code>train</code> 子目录下包含 20 个子目录，每个子目录代表一种文档的类型，子目录下的所有文档都是属于目录名称所标识的文档类型。可以随意浏览数据集，以便对数据集有一个感性的认识。例如，datasets/mlcomp/379/train/rec.autos/6652-103421是一个讨论汽车主题的帖子：</p><pre class="line-numbers language-kotlin"><code class="language-kotlin">Hahahahahaha<span class="token punctuation">.</span> gasp pant Hm<span class="token punctuation">,</span> I’m not sure whether the above was just a silly     remark <span class="token operator">or</span> a serious remark<span class="token punctuation">.</span> But <span class="token keyword">in</span> case there are some misconceptions<span class="token punctuation">,</span>I think Henry Robertson hasn’t updated his <span class="token keyword">data</span> file on Korea since…mid 1970s<span class="token punctuation">.</span> Owning a car <span class="token keyword">in</span> Korea <span class="token keyword">is</span> no longer a luxury<span class="token punctuation">.</span> Most middle <span class="token keyword">class</span> people <span class="token keyword">in</span> Korea can afford a car <span class="token operator">and</span> <span class="token keyword">do</span> have at least one car<span class="token punctuation">.</span> The problem <span class="token keyword">in</span> Korea<span class="token punctuation">,</span>especially <span class="token keyword">in</span> Seoul<span class="token punctuation">,</span> <span class="token keyword">is</span> that there are just so many privately<span class="token operator">-</span>owned cars<span class="token punctuation">,</span><span class="token keyword">as</span> well <span class="token keyword">as</span> taxis <span class="token operator">and</span> buses<span class="token punctuation">,</span> the rush<span class="token operator">-</span>hour has become a <span class="token number">24</span> hour phenomenon     <span class="token operator">and</span> that there <span class="token keyword">is</span> no place <span class="token keyword">to</span> park<span class="token punctuation">.</span> Last time I heard<span class="token punctuation">,</span> back <span class="token keyword">in</span> January<span class="token punctuation">,</span> the Kim Administration wanted <span class="token keyword">to</span> legislate a law requireing a potential car owner <span class="token keyword">to</span> provide his <span class="token operator">or</span> her own parking area<span class="token punctuation">,</span> just like they <span class="token keyword">do</span> <span class="token keyword">in</span> Japan<span class="token punctuation">.</span>Also<span class="token punctuation">,</span> Henry would be glad <span class="token keyword">to</span> know that Hyundai isn’t the only car manufacturer <span class="token keyword">in</span> Korea<span class="token punctuation">.</span> Daewoo has always manufactured cars <span class="token operator">and</span> I believe Kia <span class="token keyword">is</span> back <span class="token keyword">in</span> business <span class="token keyword">as</span> well<span class="token punctuation">.</span> Imported cars<span class="token punctuation">,</span> such <span class="token keyword">as</span> Mercury Sable are becoming quite popular <span class="token keyword">as</span> well<span class="token punctuation">,</span> though they are still quite expensive<span class="token punctuation">.</span>Finally<span class="token punctuation">,</span> please ignore Henry’s posting about Korean politics <span class="token operator">and</span> bureaucracy<span class="token punctuation">.</span>     He’s quite uninformed<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-2-文档的数学表达"><a href="#5-2-文档的数学表达" class="headerlink" title="5.2 文档的数学表达"></a>5.2 文档的数学表达</h3><p>怎样把一个文档表达为计算机可以理解并处理的信息，是自然语言处理中的一个重要课题，完整内容可以写成鸿篇巨著。本节简单介绍TF-IDF的原理，以便更好地理解本文介绍的实例。</p><p><code>TF-IDF</code> 是一种统计方法，用以评估一个词语对于一份文档的重要程度。<code>TF（Term Frequency）</code>表示词频，对于一份文档而言，词频是指特定词语在这篇文档里出现的次数除以该文档总词数。例如，一篇文档一共有1000个词，其中“朴素贝叶斯”出现了5次，“的”出现了25次，“应用”出现了12次，那么它们的词频分别是0.005，0.025和0.012。</p><p><code>IDF（Inverse Document Frequency）</code>表示一个词的逆向文档频率，由总文档数除以包含该词的文档数的商再取对数得到。例如：我们的数据集一共10000篇文档，其中“朴素贝叶斯”只出现在10篇文档中，则其<code>IDF=log(10000/10)=3</code>；“的”在所有文档中都出现过，则其 <code>IDF=log(10000/10000)=0</code>；“应用”在1000篇文档中出现过，则其 <code>IDF=log(10000/1000)=1</code>。</p><p>计算出每个词的TF和IDF之后，两者相乘，即可得到这个词在文档中的重要程度。词语的重要性与它在该文档中出现的次数成正比，与它在语料库中出现的文档数成反比。</p><p>有了TF-IDF这个工具，我们就可以把一篇文档转换为一个向量。首先，可以从数据集<code>（在自然语言处理领域也称corpus，即语料库）</code>里提取出所有出现的词，我们称为词典。假设词典里总共有10000个词语，则每个文档都可以转化为一个10000维的向量。其次，针对我们要转换的文档里出现的每个词语，都去计算其TF-IDF，并把这个值填入文档向量里这个词对应的元素上。这样就完成了把一篇文档转换为一个向量的过程。一个文档往往只会由词典里的一小部分词语构成，这就意味着这个向量里的大部分元素都是0。</p><p>所幸，上述过程不需要我们自己写代码去完成，<code>scikit-learn</code> 软件包里实现了把文档转换为向量的过程。首先，把训练用的语料库读入内存：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> time <span class="token keyword">import</span> time<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>datasets <span class="token keyword">import</span> load_files<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"loading train dataset ..."</span><span class="token punctuation">)</span>t <span class="token operator">=</span> time<span class="token punctuation">(</span><span class="token punctuation">)</span>news_train <span class="token operator">=</span> load_files<span class="token punctuation">(</span><span class="token string">'datasets/mlcomp/379/train'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"summary: {0} documents in {1} categories."</span>      <span class="token punctuation">.</span>format<span class="token punctuation">(</span>len<span class="token punctuation">(</span>news_train<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>news_train<span class="token punctuation">.</span>target_names<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"done in {0} seconds"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出如下：</p><pre class="line-numbers language-bash"><code class="language-bash">loading train dataset <span class="token punctuation">..</span>.summary: 13180 documents <span class="token keyword">in</span> 20 categories.<span class="token keyword">done</span> <span class="token keyword">in</span> 1.2616519927978516 seconds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中，<code>datasets/mlcomp/379/train</code>目录下放的就是我们的语料库，其中包含20个子目录，每个子目录的名字表示的是文档的类别，子目录下包含这种类别的所有文档。<code>load_files()</code> 函数会从这个目录里把所有的文档都读入内存，并且自动根据所在的子目录名称打上标签。其中，<code>news_train.data</code>是一个数组，里面包含了所有文档的文本信息。<code>news_train.target</code>也是一个数组，包含了所有文档所属的类别，而<code>news_train.target_names</code>则是类别的名称，因此，如果我们想知道第一篇文档所属的类别名称，只需要通过代码<code>news_train.target_names[news_train.target[0]]</code>即可得到。</p><p>该语料库里总共有13180个文档，分成20个类别。接着需要把这些文档全部转换为由TF-IDF表达的权重信息构成的向量：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>feature_extraction<span class="token punctuation">.</span>text <span class="token keyword">import</span> TfidfVectorizer<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"vectorizing train dataset ..."</span><span class="token punctuation">)</span>t <span class="token operator">=</span> time<span class="token punctuation">(</span><span class="token punctuation">)</span>vectorizer <span class="token operator">=</span> TfidfVectorizer<span class="token punctuation">(</span>encoding<span class="token operator">=</span><span class="token string">'latin-1'</span><span class="token punctuation">)</span>X_train <span class="token operator">=</span> vectorizer<span class="token punctuation">.</span>fit_transform<span class="token punctuation">(</span><span class="token punctuation">(</span>d <span class="token keyword">for</span> d <span class="token keyword">in</span> news_train<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"n_samples: %d, n_features: %d"</span> <span class="token operator">%</span> X_train<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"number of non-zero features in samples [{0}]:{1}"</span>      <span class="token punctuation">.</span>format<span class="token punctuation">(</span>news_train<span class="token punctuation">.</span>filenames<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>X_train<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>getnnz<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"done in {0} seconds"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出如下：</p><pre class="line-numbers language-css"><code class="language-css">vectorizing train dataset <span class="token number">...</span><span class="token property">n_samples</span><span class="token punctuation">:</span> <span class="token number">13180</span>, <span class="token property">n_features</span><span class="token punctuation">:</span> <span class="token number">130274</span>number of non-zero features in samples [datasets/mlcomp/<span class="token number">379</span>/train\talk<span class="token number">.</span>politics<span class="token number">.</span>misc<span class="token entity" title="\17860">\17860</span>-<span class="token number">178992</span>]<span class="token punctuation">:</span><span class="token number">108</span>done in <span class="token number">2.6174726486206055</span> seconds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其中，<code>TfidfVectorizer</code>类是用来把所有的文档转换为矩阵，该矩阵每行都代表一个文档，一行中的每个元素代表一个对应的词语的重要性，词语的重要性由<code>TF-IDF</code>来表示。其 <code>fit_transform()</code> 方法是 fit() 和transform()合并起来。其中，fit()  会先完成语料库分析、提取词典等操作，transform()会把对每篇文档转换为向量，最终构成一个矩阵，保存在X_train变量里。</p><p>由输出可以知道，我们的词典总共有 130274 个词语，即每篇文档都可转换为一个 130274 维的向量。第一篇文档中，只有108个非零元素，即这篇文档总共由108个不重复的单词组成，在这篇文档中出现的这108个单词的TF-IDF值会被计算出来，并保存在向量中的指定位置上。X_train是一个维度为13180*130274的稀疏矩阵。</p><p>X_train稀疏矩阵由一个三元组(row,col,score)构成：</p><pre class="line-numbers language-bash"><code class="language-bash">print<span class="token punctuation">(</span>X_train<span class="token punctuation">[</span>0<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出如下：</p><pre class="line-numbers language-css"><code class="language-css">  <span class="token punctuation">(</span><span class="token number">0</span>, <span class="token number">56813</span><span class="token punctuation">)</span>    <span class="token number">0.014332663773643272</span>  <span class="token punctuation">(</span><span class="token number">0</span>, <span class="token number">45689</span><span class="token punctuation">)</span>    <span class="token number">0.08373343949755</span>  <span class="token punctuation">(</span><span class="token number">0</span>, <span class="token number">46084</span><span class="token punctuation">)</span>    <span class="token number">0.08109733529789522</span>  <span class="token punctuation">(</span><span class="token number">0</span>, <span class="token number">125882</span><span class="token punctuation">)</span>   <span class="token number">0.0873157704840211</span>  <span class="token punctuation">(</span><span class="token number">0</span>, <span class="token number">50150</span><span class="token punctuation">)</span>    <span class="token number">0.020654313721609956</span>  <span class="token punctuation">(</span><span class="token number">0</span>, <span class="token number">87702</span><span class="token punctuation">)</span>    <span class="token number">0.04643235585055511</span>  <span class="token punctuation">(</span><span class="token number">0</span>, <span class="token number">33334</span><span class="token punctuation">)</span>    <span class="token number">0.1025405658189532</span>  <span class="token punctuation">(</span><span class="token number">0</span>, <span class="token number">111805</span><span class="token punctuation">)</span>   <span class="token number">0.</span><span class="token property">014332663773643272</span>  <span class="token punctuation">:</span> <span class="token punctuation">:</span>  <span class="token punctuation">(</span><span class="token number">0</span>, <span class="token number">67768</span><span class="token punctuation">)</span>    <span class="token number">0.08982314745972582</span>  <span class="token punctuation">(</span><span class="token number">0</span>, <span class="token number">41790</span><span class="token punctuation">)</span>    <span class="token number">0.09260592033433869</span>  <span class="token punctuation">(</span><span class="token number">0</span>, <span class="token number">105800</span><span class="token punctuation">)</span>   <span class="token number">0.08713990737243116</span>  <span class="token punctuation">(</span><span class="token number">0</span>, <span class="token number">37075</span><span class="token punctuation">)</span>    <span class="token number">0.10018566542781165</span>  <span class="token punctuation">(</span><span class="token number">0</span>, <span class="token number">23162</span><span class="token punctuation">)</span>    <span class="token number">0.08920437523600384</span>  <span class="token punctuation">(</span><span class="token number">0</span>, <span class="token number">124699</span><span class="token punctuation">)</span>   <span class="token number">0.06257976758779137</span>  <span class="token punctuation">(</span><span class="token number">0</span>, <span class="token number">94119</span><span class="token punctuation">)</span>    <span class="token number">0.1159317059788844</span>  <span class="token punctuation">(</span><span class="token number">0</span>, <span class="token number">56555</span><span class="token punctuation">)</span>    <span class="token number">0.06984885482106491</span>  <span class="token punctuation">(</span><span class="token number">0</span>, <span class="token number">62776</span><span class="token punctuation">)</span>    <span class="token number">0.10474995568339582</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-3-模型训练"><a href="#5-3-模型训练" class="headerlink" title="5.3 模型训练"></a>5.3 模型训练</h3><p>使用 <code>MultinomialNB</code> 对数据集进行训练：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>naive_bayes <span class="token keyword">import</span> MultinomialNB<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"training models ..."</span><span class="token punctuation">)</span>t <span class="token operator">=</span> time<span class="token punctuation">(</span><span class="token punctuation">)</span>y_train <span class="token operator">=</span> news_train<span class="token punctuation">.</span>targetclf <span class="token operator">=</span> MultinomialNB<span class="token punctuation">(</span>alpha<span class="token operator">=</span><span class="token number">0.0001</span><span class="token punctuation">)</span>clf<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span>y_train<span class="token punctuation">)</span>train_score <span class="token operator">=</span> clf<span class="token punctuation">.</span>score<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span>y_train<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"train score: {0}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>train_score<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"done in {0} seconds"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出如下：</p><pre class="line-numbers language-css"><code class="language-css">training models <span class="token number">...</span>train <span class="token property">score</span><span class="token punctuation">:</span> <span class="token number">0.9978755690440061</span>done in <span class="token number">0.15497064590454102</span> seconds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中，alpha表示平滑参数，其值越小，越容易造成过拟合，值太大，容易造成欠拟合。</p><p>接着，我们加载测试数据集，并用一篇文档来预测其是否准确。测试数据集在<code>datasets/mlcomp/379/test</code>目录下，我们用前面介绍的相同的方法先加载数据集：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"loading test dataset ..."</span><span class="token punctuation">)</span>t <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token punctuation">)</span>news_test <span class="token operator">=</span> <span class="token function">load_files</span><span class="token punctuation">(</span><span class="token string">'datasets/mlcomp/379/test'</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"summary: {0} documents in {1} categories."</span>      <span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>news_test<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">len</span><span class="token punctuation">(</span>news_test<span class="token punctuation">.</span>target_names<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"done in {0} seconds"</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出如下：</p><pre class="line-numbers language-bash"><code class="language-bash">loading <span class="token function">test</span> dataset <span class="token punctuation">..</span>.summary: 5648 documents <span class="token keyword">in</span> 20 categories.<span class="token keyword">done</span> <span class="token keyword">in</span> 0.3548290729522705 seconds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>测试数据集共有5648篇文档。接着，我们把文档向量化：</p><pre class="line-numbers language-bash"><code class="language-bash">print<span class="token punctuation">(</span><span class="token string">"vectorizing test dataset ..."</span><span class="token punctuation">)</span>t <span class="token operator">=</span> time<span class="token punctuation">(</span><span class="token punctuation">)</span>X_test <span class="token operator">=</span> vectorizer.transform<span class="token variable"><span class="token punctuation">((</span>d for d in news_test.data<span class="token punctuation">))</span></span>y_test <span class="token operator">=</span> news_test.targetprint<span class="token punctuation">(</span><span class="token string">"n_samples: %d, n_features: %d"</span> % X_test.shape<span class="token punctuation">)</span>print<span class="token punctuation">(</span><span class="token string">"number of non-zero features in sample [{0}]: {1}"</span>      .format<span class="token punctuation">(</span>news_test.filenames<span class="token punctuation">[</span>0<span class="token punctuation">]</span>,X_test<span class="token punctuation">[</span>0<span class="token punctuation">]</span>.getnnz<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">)</span>print<span class="token punctuation">(</span><span class="token string">"done in {0} seconds"</span>.format<span class="token punctuation">(</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>-t<span class="token punctuation">))</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出如下：</p><pre class="line-numbers language-bash"><code class="language-bash">vectorizing <span class="token function">test</span> dataset <span class="token punctuation">..</span>.n_samples: 5648, n_features: 130274number of non-zero features <span class="token keyword">in</span> sample <span class="token punctuation">[</span>datasets/mlcomp/379/test\rec.autos\7429-103268<span class="token punctuation">]</span>: 61<span class="token keyword">done</span> <span class="token keyword">in</span> 0.9695498943328857 seconds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意，vectorizer变量是我们处理训练数据集时用到的向量化的类的实例，此处我们只需要调用transform()进行TF-IDF数值计算即可，不需要再调用fit()进行语料库分析了。</p><p>这样，我们的测试数据集也转换为了一个维度为5648*130274的稀疏矩阵。可以取测试数据集里的第一篇文档初步验证一下，看看训练出来的模型能否正确地预测这个文档所属的类别：</p><pre class="line-numbers language-bash"><code class="language-bash">pred <span class="token operator">=</span> clf.predict<span class="token punctuation">(</span>X_test<span class="token punctuation">[</span>0<span class="token punctuation">]</span><span class="token punctuation">)</span>print<span class="token punctuation">(</span><span class="token string">"predict: {0} is in category {1}"</span>      .format<span class="token punctuation">(</span>news_test.filenames<span class="token punctuation">[</span>0<span class="token punctuation">]</span>,news_test.target_names<span class="token punctuation">[</span>pred<span class="token punctuation">[</span>0<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">))</span>print<span class="token punctuation">(</span><span class="token string">"actually: {0} is in category {1}"</span>      .format<span class="token punctuation">(</span>news_test.filenames<span class="token punctuation">[</span>0<span class="token punctuation">]</span>,news_test.target_names<span class="token punctuation">[</span>news_test.target<span class="token punctuation">[</span>0<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">))</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出如下：</p><pre class="line-numbers language-bash"><code class="language-bash">predict: datasets/mlcomp/379/test\rec.autos\7429-103268 is <span class="token keyword">in</span> category rec.autosactually: datasets/mlcomp/379/test\rec.autos\7429-103268 is <span class="token keyword">in</span> category rec.autos<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>看来预测的结果和实际结果是相符的。</p><h3 id="5-4-模型评价"><a href="#5-4-模型评价" class="headerlink" title="5.4 模型评价"></a>5.4 模型评价</h3><p>虽然通过验证，说明我们训练的模型是可用的，但是不能通过一个样本的预测来评价模型的准确性。我们需要对模型有个全方位的评价，所幸 <code>scikit-learn</code> 软件包提供了全方位的模型评价工具。</p><p>首先需要对测试数据集进行预测：</p><pre class="line-numbers language-bash"><code class="language-bash">print<span class="token punctuation">(</span><span class="token string">"predicting test dataset ..."</span><span class="token punctuation">)</span>t <span class="token operator">=</span> time<span class="token punctuation">(</span><span class="token punctuation">)</span>pred_test <span class="token operator">=</span> clf.predict<span class="token punctuation">(</span>X_test<span class="token punctuation">)</span>print<span class="token punctuation">(</span><span class="token string">"done in %fs"</span> % <span class="token punctuation">(</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>-t<span class="token punctuation">))</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>接着使用 <code>classification_report()</code> 函数来查看一下针对每个类别的预测准确性：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>metrics <span class="token keyword">import</span> classification_report<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"classification report on test set for classifier:"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>clf<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>classification_report<span class="token punctuation">(</span>y_test<span class="token punctuation">,</span>pred_test<span class="token punctuation">,</span>target_names<span class="token operator">=</span>news_test<span class="token punctuation">.</span>target_names<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>输出如下：</p><pre class="line-numbers language-bash"><code class="language-bash">classification report on <span class="token function">test</span> <span class="token keyword">set</span> <span class="token keyword">for</span> classifier:MultinomialNB<span class="token punctuation">(</span>alpha<span class="token operator">=</span>0.0001, class_prior<span class="token operator">=</span>None, fit_prior<span class="token operator">=</span>True<span class="token punctuation">)</span>                          precision    recall  f1-score   support             alt.atheism       0.90      0.91      0.91       245           comp.graphics       0.80      0.90      0.85       298 comp.os.ms-windows.misc       0.82      0.79      0.80       292comp.sys.ibm.pc.hardware       0.81      0.80      0.81       301   comp.sys.mac.hardware       0.90      0.91      0.91       256          comp.windows.x       0.88      0.88      0.88       297            misc.forsale       0.87      0.81      0.84       290               rec.autos       0.92      0.93      0.92       324         rec.motorcycles       0.96      0.96      0.96       294      rec.sport.baseball       0.97      0.94      0.96       315        rec.sport.hockey       0.96      0.99      0.98       302               sci.crypt       0.95      0.96      0.95       297         sci.electronics       0.91      0.85      0.88       313                 sci.med       0.96      0.96      0.96       277               sci.space       0.94      0.97      0.96       305  soc.religion.christian       0.93      0.96      0.94       293      talk.politics.guns       0.91      0.96      0.93       246   talk.politics.mideast       0.96      0.98      0.97       296      talk.politics.misc       0.90      0.90      0.90       236      talk.religion.misc       0.89      0.78      0.83       171             avg / total       0.91      0.91      0.91      5648<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从输出结果中可以看出，针对每种类别都统计了<code>查准率</code>、<code>召回率</code>和<code>F1-Score</code>。此外，还可以通过confusion_matrix()函数生成混淆矩阵，观察每种类别被错误分类的情况。例如，这些被错误分类的文档是被错误分类到哪些类别里的：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>metrics <span class="token keyword">import</span> confusion_matrixcm <span class="token operator">=</span> confusion_matrix<span class="token punctuation">(</span>y_test<span class="token punctuation">,</span>pred_test<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"confusion matrix:\n"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>cm<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>输出如下：</p><pre class="line-numbers language-csharp"><code class="language-csharp">confusion matrix<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">224</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">2</span>   <span class="token number">5</span>   <span class="token number">0</span>   <span class="token number">0</span>    <span class="token number">1</span>  <span class="token number">13</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>  <span class="token number">1</span> <span class="token number">267</span>   <span class="token number">5</span>   <span class="token number">5</span>   <span class="token number">2</span>   <span class="token number">8</span>   <span class="token number">1</span>   <span class="token number">1</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">2</span>   <span class="token number">3</span>   <span class="token number">2</span>   <span class="token number">1</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>    <span class="token number">0</span>   <span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>  <span class="token number">1</span>  <span class="token number">13</span> <span class="token number">230</span>  <span class="token number">24</span>   <span class="token number">4</span>  <span class="token number">10</span>   <span class="token number">5</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">1</span>   <span class="token number">2</span>   <span class="token number">1</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>    <span class="token number">1</span>   <span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>  <span class="token number">0</span>   <span class="token number">9</span>  <span class="token number">21</span> <span class="token number">242</span>   <span class="token number">7</span>   <span class="token number">2</span>  <span class="token number">10</span>   <span class="token number">1</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">1</span>   <span class="token number">1</span>   <span class="token number">7</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>    <span class="token number">0</span>   <span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>  <span class="token number">0</span>   <span class="token number">1</span>   <span class="token number">5</span>   <span class="token number">5</span> <span class="token number">233</span>   <span class="token number">2</span>   <span class="token number">2</span>   <span class="token number">2</span>   <span class="token number">1</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">3</span>   <span class="token number">1</span>   <span class="token number">0</span>   <span class="token number">1</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>    <span class="token number">0</span>   <span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>  <span class="token number">0</span>  <span class="token number">20</span>   <span class="token number">6</span>   <span class="token number">3</span>   <span class="token number">1</span> <span class="token number">260</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">2</span>   <span class="token number">0</span>   <span class="token number">1</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">2</span>   <span class="token number">0</span>   <span class="token number">2</span>   <span class="token number">0</span>    <span class="token number">0</span>   <span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>  <span class="token number">0</span>   <span class="token number">2</span>   <span class="token number">5</span>  <span class="token number">12</span>   <span class="token number">3</span>   <span class="token number">1</span> <span class="token number">235</span>  <span class="token number">10</span>   <span class="token number">2</span>   <span class="token number">3</span>   <span class="token number">1</span>   <span class="token number">0</span>   <span class="token number">7</span>   <span class="token number">0</span>   <span class="token number">2</span>   <span class="token number">0</span>   <span class="token number">2</span>   <span class="token number">1</span>    <span class="token number">4</span>   <span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>  <span class="token number">0</span>   <span class="token number">1</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">1</span>   <span class="token number">0</span>   <span class="token number">8</span> <span class="token number">300</span>   <span class="token number">4</span>   <span class="token number">1</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">1</span>   <span class="token number">2</span>   <span class="token number">3</span>   <span class="token number">0</span>   <span class="token number">2</span>   <span class="token number">0</span>    <span class="token number">1</span>   <span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>  <span class="token number">0</span>   <span class="token number">1</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">2</span>   <span class="token number">2</span>   <span class="token number">3</span> <span class="token number">283</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">1</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>    <span class="token number">1</span>   <span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>  <span class="token number">0</span>   <span class="token number">1</span>   <span class="token number">1</span>   <span class="token number">0</span>   <span class="token number">1</span>   <span class="token number">2</span>   <span class="token number">1</span>   <span class="token number">2</span>   <span class="token number">0</span> <span class="token number">297</span>   <span class="token number">8</span>   <span class="token number">1</span>   <span class="token number">0</span>   <span class="token number">1</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>    <span class="token number">0</span>   <span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>  <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">2</span>   <span class="token number">2</span> <span class="token number">298</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>    <span class="token number">0</span>   <span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>  <span class="token number">0</span>   <span class="token number">1</span>   <span class="token number">2</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">1</span>   <span class="token number">1</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span> <span class="token number">284</span>   <span class="token number">2</span>   <span class="token number">1</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">2</span>   <span class="token number">1</span>    <span class="token number">2</span>   <span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>  <span class="token number">0</span>  <span class="token number">11</span>   <span class="token number">3</span>   <span class="token number">5</span>   <span class="token number">4</span>   <span class="token number">2</span>   <span class="token number">4</span>   <span class="token number">5</span>   <span class="token number">1</span>   <span class="token number">1</span>   <span class="token number">0</span>   <span class="token number">4</span> <span class="token number">266</span>   <span class="token number">1</span>   <span class="token number">4</span>   <span class="token number">0</span>   <span class="token number">1</span>   <span class="token number">0</span>    <span class="token number">1</span>   <span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>  <span class="token number">1</span>   <span class="token number">1</span>   <span class="token number">0</span>   <span class="token number">1</span>   <span class="token number">0</span>   <span class="token number">2</span>   <span class="token number">1</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">1</span> <span class="token number">266</span>   <span class="token number">2</span>   <span class="token number">1</span>   <span class="token number">0</span>   <span class="token number">0</span>    <span class="token number">1</span>   <span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>  <span class="token number">0</span>   <span class="token number">3</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">1</span>   <span class="token number">1</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">1</span>   <span class="token number">0</span>   <span class="token number">1</span> <span class="token number">296</span>   <span class="token number">0</span>   <span class="token number">1</span>   <span class="token number">0</span>    <span class="token number">1</span>   <span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>  <span class="token number">3</span>   <span class="token number">1</span>   <span class="token number">0</span>   <span class="token number">1</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">1</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">2</span>   <span class="token number">1</span> <span class="token number">280</span>   <span class="token number">0</span>   <span class="token number">1</span>    <span class="token number">1</span>   <span class="token number">2</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>  <span class="token number">1</span>   <span class="token number">0</span>   <span class="token number">2</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">1</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span> <span class="token number">236</span>   <span class="token number">1</span>    <span class="token number">4</span>   <span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>  <span class="token number">1</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">1</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">3</span>   <span class="token number">0</span> <span class="token number">290</span>    <span class="token number">1</span>   <span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>  <span class="token number">2</span>   <span class="token number">1</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">1</span>   <span class="token number">1</span>   <span class="token number">0</span>   <span class="token number">1</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">1</span>  <span class="token number">10</span>   <span class="token number">7</span>  <span class="token number">212</span>   <span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">[</span> <span class="token number">16</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>  <span class="token number">12</span>   <span class="token number">4</span>   <span class="token number">1</span>    <span class="token number">4</span> <span class="token number">134</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例如：从第一行可以看出，类别0（alt.atheism）的文档，有13个被错误地分类到类别19（talk.religion.misc）里。当然，我们还可以把混淆矩阵进行数据可视化：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Show confusion matrix</span><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> pltplt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">,</span>dpi<span class="token operator">=</span><span class="token number">144</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'Confusion matrix of the classifier'</span><span class="token punctuation">)</span>ax <span class="token operator">=</span> plt<span class="token punctuation">.</span>gca<span class="token punctuation">(</span><span class="token punctuation">)</span>ax<span class="token punctuation">.</span>spines<span class="token punctuation">[</span><span class="token string">'right'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_color<span class="token punctuation">(</span><span class="token string">'none'</span><span class="token punctuation">)</span>ax<span class="token punctuation">.</span>spines<span class="token punctuation">[</span><span class="token string">'top'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_color<span class="token punctuation">(</span><span class="token string">'none'</span><span class="token punctuation">)</span>ax<span class="token punctuation">.</span>spines<span class="token punctuation">[</span><span class="token string">'bottom'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_color<span class="token punctuation">(</span><span class="token string">'none'</span><span class="token punctuation">)</span>ax<span class="token punctuation">.</span>spines<span class="token punctuation">[</span><span class="token string">'left'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_color<span class="token punctuation">(</span><span class="token string">'none'</span><span class="token punctuation">)</span>ax<span class="token punctuation">.</span>xaxis<span class="token punctuation">.</span>set_ticks_position<span class="token punctuation">(</span><span class="token string">'none'</span><span class="token punctuation">)</span>ax<span class="token punctuation">.</span>yaxis<span class="token punctuation">.</span>set_ticks_position<span class="token punctuation">(</span><span class="token string">'none'</span><span class="token punctuation">)</span>ax<span class="token punctuation">.</span>set_xticklabels<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>ax<span class="token punctuation">.</span>set_yticklabels<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>matshow<span class="token punctuation">(</span>cm<span class="token punctuation">,</span>fignum<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>cmap<span class="token operator">=</span><span class="token string">'gray'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>colorbar<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出图形如下：</p><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200702160731221.png" alt="image-20200702160731221">除对角线外，其他地方颜色越浅，说明此处错误越多。通过这些数据，我们可以详细分析样本数据，找出为什么某种类别会被错误地分类到另一种类别里，从而进一步优化模型。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> ML算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scikit-learn系列六：SVM</title>
      <link href="/2020/07/01/scikit-learn-xi-lie-liu-svm/"/>
      <url>/2020/07/01/scikit-learn-xi-lie-liu-svm/</url>
      
        <content type="html"><![CDATA[<h2 id="项目地址传送门，欢迎-star-和-fork-！"><a href="#项目地址传送门，欢迎-star-和-fork-！" class="headerlink" title="项目地址传送门，欢迎 star 和 fork ！"></a>项目地址<a href="https://github.com/DongZhouGu/scikit-learn-ml" target="_blank" rel="noopener">传送门</a>，欢迎 star 和 fork ！</h2><h2 id="1-SVM概述"><a href="#1-SVM概述" class="headerlink" title="1. SVM概述"></a>1. SVM概述</h2><p>支持向量机(Support Vector Machines, SVM): 是一种监督学习算法。在工业界和学术界都有广泛的应用。特别是针对数据集较小的情况下，往往其分类效果比神经网络好。</p><ul><li>支持向量(Support Vector) 就是离分隔超平面最近的那些点。</li><li>机(Machine) 就是表示一种算法，而不是表示机器。</li></ul><h2 id="2-SVM原理"><a href="#2-SVM原理" class="headerlink" title="2. SVM原理"></a>2. SVM原理</h2><p>SVM的原理就是使用分隔超平面来划分数据集，并使得支持向量（数据集中离分隔超平面最近的点）到该分隔超平面的距离最大。其最大特点是能构造出最大间距的决策边界，从而提高分类算法的鲁棒性。</p><p>要给左右两边的点进行分类，明显发现: 选择D会比B、C分隔的效果要好很多。</p><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/SVM_3_linearly-separable.jpg" alt="线性可分"></p><h3 id="2-1-寻找最大间隔"><a href="#2-1-寻找最大间隔" class="headerlink" title="2.1 寻找最大间隔"></a>2.1 寻找最大间隔</h3><h4 id="点到超平面的距离"><a href="#点到超平面的距离" class="headerlink" title="点到超平面的距离"></a>点到超平面的距离</h4><ul><li><p>分隔超平面<code>函数间距</code>:  $y(x)=w^Tx+b$</p></li><li><p>分类的结果:  $f(x)=sign(w^Tx+b)$   (sign表示&gt;0为1，&lt;0为-1，=0为0) </p></li><li><p>点到超平面的<code>几何间距</code>: $d(x)=(w^Tx+b)/||w||$  （$||w||$表示w矩阵的二范数=&gt; $\sqrt{w^T*w}$, 点到超平面的距离也是类似的）</p></li></ul><p>$$<br>d=\left|\frac{A x_{0}+B y_{0}+C}{\sqrt{A^{2}+B^{2}}}\right|<br>$$</p><h4 id="拉格朗日乘子法"><a href="#拉格朗日乘子法" class="headerlink" title="拉格朗日乘子法"></a>拉格朗日乘子法</h4><ul><li>类别标签用-1、1，是为了后期方便 $ label<em>(w^Tx+b)$ 的标识和距离计算；如果 $label</em>(w^Tx+b)&gt;0$ 表示预测正确，否则预测错误。</li><li>现在目标很明确，就是要找到<code>w</code>和<code>b</code>，因此我们必须要找到最小间隔的数据点，也就是前面所说的<code>支持向量</code>。<ul><li>也就说，让最小的距离取最大.(最小的距离: 就是最小间隔的数据点；最大: 就是最大间距，为了找出最优超平面–最终就是支持向量)</li><li>目标函数: $arg: max_{关于w, b} \left( min[label<em>(w^Tx+b)]</em>\frac{1}{||w||} \right) $<ol><li>如果 $label*(w^Tx+b)&gt;0$ 表示预测正确，也称<code>函数间隔</code>，$||w||$ 可以理解为归一化，也称<code>几何间隔</code>。</li><li>令 $label<em>(w^Tx+b)&gt;=1$， 因为0～1之间，得到的点是存在误判的可能性，所以要保障 $min[label</em>(w^Tx+b)]=1$，才能更好降低噪音数据影响。</li><li>所以本质上是求 $arg: max_{关于w, b}  \frac{1}{||w||} $；也就说，我们约束(前提)条件是: $label*(w^Tx+b)=1$</li></ol></li></ul></li><li>新的目标函数求解:  $arg: max_{关于w, b}  \frac{1}{||w||} $<ul><li>=&gt; 就是求: $arg: min_{关于w, b} ||w|| $ (求矩阵会比较麻烦，如果x只是 $\frac{1}{2}*x^2$ 的偏导数，那么。。同样是求最小值)</li><li>=&gt; 就是求: $arg: min_{关于w, b} (\frac{1}{2}*||w||^2)$ (二次函数求导，求极值，平方也方便计算)</li><li>本质上就是求线性不等式的二次优化问题(求分隔超平面，等价于求解相应的凸二次规划问题)</li></ul></li><li>通过拉格朗日乘子法，求二次优化问题<ul><li>假设需要求极值的目标函数 (objective function) 为 f(x,y)，限制条件为 φ(x,y)=M  # M=1</li><li>设g(x,y)=M-φ(x,y)   # 临时φ(x,y)表示下文中 $label*(w^Tx+b)$</li><li>定义一个新函数: F(x,y,λ)=f(x,y)+λg(x,y)</li><li>a为λ（a&gt;=0），代表要引入的拉格朗日乘子(Lagrange multiplier)</li><li>那么:  $L(w,b,\alpha)=\frac{1}{2} * ||w||^2 + \sum_{i=1}^{n} \alpha_i * [1 - label * (w^Tx+b)]$</li><li>因为: $label<em>(w^Tx+b)&gt;=1, \alpha&gt;=0$ , 所以 $\alpha</em>[1-label<em>(w^Tx+b)]&lt;=0$ , $\sum_{i=1}^{n} \alpha_i * [1-label</em>(w^Tx+b)]&lt;=0$ </li><li>当 $label*(w^Tx+b)&gt;1$ 则 $\alpha=0$ ，表示该点为<font color="red">非支持向量</font></li><li>相当于求解:  $max_{关于\alpha} L(w,b,\alpha) = \frac{1}{2} *||w||^2$ </li><li>如果求:  $min_{关于w, b} \frac{1}{2} *||w||^2$ , 也就是要求:  $min_{关于w, b} \left( max_{关于\alpha} L(w,b,\alpha)\right)$ </li></ul></li><li>现在转化到对偶问题的求解<ul><li>$min_{关于w, b} \left(max_{关于\alpha} L(w,b,\alpha) \right) $ &gt;= $max_{关于\alpha} \left(min_{关于w, b}\ L(w,b,\alpha) \right) $ </li><li>现在分2步</li><li>先求:  $min_{关于w, b} L(w,b,\alpha)=\frac{1}{2} * ||w||^2 + \sum_{i=1}^{n} \alpha_i * [1 - label * (w^Tx+b)]$</li><li>就是求<code>L(w,b,a)</code>关于[w, b]的偏导数, 得到<code>w和b的值</code>，并化简为: <code>L和a的方程</code>。</li><li>参考:  如果公式推导还是不懂，也可以参考《统计学习方法》李航-P103&lt;学习的对偶算法&gt;<br><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/SVM_%E6%9D%BE%E5%BC%9B%E5%8F%98%E9%87%8F.jpg" alt="计算拉格朗日函数的对偶函数"></li></ul></li><li>终于得到课本上的公式:  $max_{关于\alpha} \left( \sum_{i=1}^{m} \alpha_i - \frac{1}{2} \sum_{i, j=1}^{m} label_i·label_j·\alpha_i·\alpha_j·&lt;x_i, x_j&gt; \right) $</li><li>约束条件:  $a&gt;=0$ 并且 $\sum_{i=1}^{m} a_i·label_i=0$</li></ul><h3 id="2-2-松弛变量-slack-variable"><a href="#2-2-松弛变量-slack-variable" class="headerlink" title="2.2 松弛变量(slack variable)"></a>2.2 松弛变量(slack variable)</h3><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/%E6%9D%BE%E5%BC%9B%E5%8F%98%E9%87%8F.png" alt="松弛变量公式"></p><ul><li>我们知道几乎所有的数据都不那么干净, 通过引入松弛变量来 <code>允许数据点可以处于分隔面错误的一侧</code>。</li><li>约束条件:  $C&gt;=a&gt;=0$ 并且 $\sum_{i=1}^{m} a_i·label_i=0$</li><li>总的来说: <ul><li><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/SVM_5_Lagrangemultiplier.png" alt="松弛变量"> 表示 <code>松弛变量</code></li><li>常量C是 <code>惩罚因子</code>, 表示离群点的权重（用于控制“最大化间隔”和“保证大部分点的函数间隔小于1.0” ）<ul><li>$label*(w^Tx+b) &gt; 1$ and alpha = 0 (在边界外，就是非支持向量)</li><li>$label*(w^Tx+b) = 1$ and 0&lt; alpha &lt; C (在分割超平面上，就支持向量)</li><li>$label*(w^Tx+b) &lt; 1$ and alpha = C (在分割超平面内，是误差点 -&gt; C表示它该受到的惩罚因子程度)</li><li>参考地址: <a href="https://www.zhihu.com/question/48351234/answer/110486455" target="_blank" rel="noopener">https://www.zhihu.com/question/48351234/answer/110486455</a></li></ul></li><li>C值越大，表示离群点影响越大，就越容易过度拟合；反之有可能欠拟合。</li><li>我们看到，目标函数控制了离群点的数目和程度，使大部分样本点仍然遵守限制条件。</li><li>例如: 正类有10000个样本，而负类只给了100个（C越大表示100个负样本的影响越大，就会出现过度拟合，所以C决定了负样本对模型拟合程度的影响！，C就是一个非常关键的优化点！）</li></ul></li><li>这一结论十分直接，SVM中的主要工作就是要求解 alpha.</li></ul><h3 id="2-3-核函数"><a href="#2-3-核函数" class="headerlink" title="2.3 核函数"></a>2.3 核函数</h3><ul><li>对于线性可分的情况，效果明显</li><li>对于非线性的情况也一样，此时需要用到一种叫<code>核函数(kernel)</code>的工具将数据转化为分类器易于理解的形式。</li></ul><blockquote><p>利用核函数将数据映射到高维空间</p></blockquote><ul><li>使用核函数: 可以将数据从某个特征空间到另一个特征空间的映射。（通常情况下: 这种映射会将低维特征空间映射到高维空间。）</li><li>如果觉得特征空间很装逼、很难理解。</li><li>可以把核函数想象成一个包装器(wrapper)或者是接口(interface)，它能将数据从某个很难处理的形式转换成为另一个较容易处理的形式。</li><li>经过空间转换后: 低维需要解决的非线性问题，就变成了高维需要解决的线性问题。</li><li>SVM 优化特别好的地方，在于所有的运算都可以写成内积(inner product: 是指2个向量相乘，得到单个标量 或者 数值)；内积替换成核函数的方式被称为<code>核技巧(kernel trick)</code>或者<code>核"变电"(kernel substation)</code></li><li>核函数并不仅仅应用于支持向量机，很多其他的机器学习算法也都用到核函数。最流行的核函数: 径向基函数(radial basis function)hecn/AiLearning/blob/master/src/py2.x/ml/6.SVM/svm-complete.py</li></ul><h2 id="3-scikit-learn里的SVM"><a href="#3-scikit-learn里的SVM" class="headerlink" title="3. scikit-learn里的SVM"></a>3. scikit-learn里的SVM</h2><p>在scikit-learn里对SVM的算法实现都在包sklearn.svm下面，其中SVC类是用来进行分类任务的，SVR类是用来进行数值回归任务的。我们可能会有疑问，SVM不是用来进行分类的算法吗，为什么可以用来进行数值回归？实际上这只是数学上的一些扩展而已，在计算机里，可以用离散的数值计算来代替连续的数值回归。我们在K-近邻算法中已经看到过这种扩展实现。</p><p>我们以 SVC 为例。首先需要选择 SVM 的核函数，由参数 kernel 来指定，其中值 linea r表示线性核函数，它只能产生直线形状的分隔超平面；值 poly 表示多项式核函数，用它可以构建出复杂形状的分隔超平面；值 rbf 表示径向基核函数，即高斯核函数。</p><p>不同的核函数需要指定不同的参数。针对线性核函数，只需要指定参数 C，它表示对不符合最大间距规则的样本的惩罚力度，即前面介绍的松弛系数。针对多项式核函数，除了参数 C 之外，还需要指定 degree，它表示多项式的阶数。针对高斯核函数，除了参数C之外，还需要指定 gamma 值，这个值对应的是高斯核函数公式中的$\frac{1}{2 \sigma^{2}}$</p><p>下面先来看一个最简单的例子。我们生成一个有两个特征、包含两种类别的数据，然后用线性核函数的SVM算法进行分类：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">def</span> <span class="token function">plot_hyperplane</span><span class="token punctuation">(</span>clf<span class="token punctuation">,</span> X<span class="token punctuation">,</span> y<span class="token punctuation">,</span>                     h<span class="token operator">=</span><span class="token number">0.02</span><span class="token punctuation">,</span>                     draw_sv<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>                     title<span class="token operator">=</span><span class="token string">'hyperplan'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># create a mesh to plot in</span>    x_min<span class="token punctuation">,</span> x_max <span class="token operator">=</span> X<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>min<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> X<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>max<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>    y_min<span class="token punctuation">,</span> y_max <span class="token operator">=</span> X<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>min<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> X<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>max<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>    xx<span class="token punctuation">,</span> yy <span class="token operator">=</span> np<span class="token punctuation">.</span>meshgrid<span class="token punctuation">(</span>np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span>x_min<span class="token punctuation">,</span> x_max<span class="token punctuation">,</span> h<span class="token punctuation">)</span><span class="token punctuation">,</span>                         np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span>y_min<span class="token punctuation">,</span> y_max<span class="token punctuation">,</span> h<span class="token punctuation">)</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span>title<span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>xlim<span class="token punctuation">(</span>xx<span class="token punctuation">.</span>min<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> xx<span class="token punctuation">.</span>max<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>ylim<span class="token punctuation">(</span>yy<span class="token punctuation">.</span>min<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> yy<span class="token punctuation">.</span>max<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>xticks<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>yticks<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    Z <span class="token operator">=</span> clf<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>np<span class="token punctuation">.</span>c_<span class="token punctuation">[</span>xx<span class="token punctuation">.</span>ravel<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> yy<span class="token punctuation">.</span>ravel<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># Put the result into a color plot</span>    Z <span class="token operator">=</span> Z<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>xx<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>contourf<span class="token punctuation">(</span>xx<span class="token punctuation">,</span> yy<span class="token punctuation">,</span> Z<span class="token punctuation">,</span> cmap<span class="token operator">=</span><span class="token string">'hot'</span><span class="token punctuation">,</span> alpha<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">)</span>    markers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'o'</span><span class="token punctuation">,</span> <span class="token string">'s'</span><span class="token punctuation">,</span> <span class="token string">'^'</span><span class="token punctuation">]</span>    colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span>    labels <span class="token operator">=</span> np<span class="token punctuation">.</span>unique<span class="token punctuation">(</span>y<span class="token punctuation">)</span>    <span class="token keyword">for</span> label <span class="token keyword">in</span> labels<span class="token punctuation">:</span>        plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>X<span class="token punctuation">[</span>y<span class="token operator">==</span>label<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                     X<span class="token punctuation">[</span>y<span class="token operator">==</span>label<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                     c<span class="token operator">=</span>colors<span class="token punctuation">[</span>label<span class="token punctuation">]</span><span class="token punctuation">,</span>                     marker<span class="token operator">=</span>markers<span class="token punctuation">[</span>label<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> draw_sv<span class="token punctuation">:</span>        sv <span class="token operator">=</span> clf<span class="token punctuation">.</span>support_vectors_        plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>sv<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> sv<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> c<span class="token operator">=</span><span class="token string">'y'</span><span class="token punctuation">,</span> marker<span class="token operator">=</span><span class="token string">'x'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sklearn <span class="token keyword">import</span> svm<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>datasets <span class="token keyword">import</span> make_blobsX<span class="token punctuation">,</span> y <span class="token operator">=</span> make_blobs<span class="token punctuation">(</span>n_samples<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">,</span> centers<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>                   random_state<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> cluster_std<span class="token operator">=</span><span class="token number">0.3</span><span class="token punctuation">)</span>clf <span class="token operator">=</span> svm<span class="token punctuation">.</span>SVC<span class="token punctuation">(</span>C<span class="token operator">=</span><span class="token number">1.0</span><span class="token punctuation">,</span> kernel<span class="token operator">=</span><span class="token string">'linear'</span><span class="token punctuation">)</span>clf<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dpi<span class="token operator">=</span><span class="token number">144</span><span class="token punctuation">)</span>plot_hyperplane<span class="token punctuation">(</span>clf<span class="token punctuation">,</span> X<span class="token punctuation">,</span> y<span class="token punctuation">,</span> h<span class="token operator">=</span><span class="token number">0.01</span><span class="token punctuation">,</span>                 title<span class="token operator">=</span><span class="token string">'Maximum Margin Hyperplan'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出的图形如下所示，其中带有x标记的点即为支持向量，它保存在模型的 <code>support_vector</code></p><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200701095026364.png" alt="image-20200701095026364"></p><p>此处需要注意的是 <code>plot_hyperplane()</code> 函数，其主要功能是画出样本点，同时画出分类区间。它的主要原理是使用 <code>numpy.meshgrid()</code> 生成一个坐标矩阵，最后用 <code>contourf()</code> 函数为坐标矩阵中不同类别的点填充不同的颜色。其中，<code>contourf()</code>函数是画等高线并填充颜色的函数。</p><p>接着来看另外一个例子。我们生成一个有两个特征、包含三种类别的数据集，然后分别构造出4个SVM算法来拟合数据集，分别是线性核函数、三阶多项式核函数、gamma=0.5的高斯核函数，以及gamma=0.1的高斯核函数。最后把这4个SVM算法拟合出来的分隔超平面画出来。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sklearn <span class="token keyword">import</span> svm<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>datasets <span class="token keyword">import</span> make_blobsX<span class="token punctuation">,</span> y <span class="token operator">=</span> make_blobs<span class="token punctuation">(</span>n_samples<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">,</span> centers<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span>                   random_state<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> cluster_std<span class="token operator">=</span><span class="token number">0.8</span><span class="token punctuation">)</span>clf_linear <span class="token operator">=</span> svm<span class="token punctuation">.</span>SVC<span class="token punctuation">(</span>C<span class="token operator">=</span><span class="token number">1.0</span><span class="token punctuation">,</span> kernel<span class="token operator">=</span><span class="token string">'linear'</span><span class="token punctuation">)</span>clf_poly <span class="token operator">=</span> svm<span class="token punctuation">.</span>SVC<span class="token punctuation">(</span>C<span class="token operator">=</span><span class="token number">1.0</span><span class="token punctuation">,</span> kernel<span class="token operator">=</span><span class="token string">'poly'</span><span class="token punctuation">,</span> degree<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span>clf_rbf <span class="token operator">=</span> svm<span class="token punctuation">.</span>SVC<span class="token punctuation">(</span>C<span class="token operator">=</span><span class="token number">1.0</span><span class="token punctuation">,</span> kernel<span class="token operator">=</span><span class="token string">'rbf'</span><span class="token punctuation">,</span> gamma<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">)</span>clf_rbf2 <span class="token operator">=</span> svm<span class="token punctuation">.</span>SVC<span class="token punctuation">(</span>C<span class="token operator">=</span><span class="token number">1.0</span><span class="token punctuation">,</span> kernel<span class="token operator">=</span><span class="token string">'rbf'</span><span class="token punctuation">,</span> gamma<span class="token operator">=</span><span class="token number">0.1</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dpi<span class="token operator">=</span><span class="token number">144</span><span class="token punctuation">)</span>clfs <span class="token operator">=</span> <span class="token punctuation">[</span>clf_linear<span class="token punctuation">,</span> clf_poly<span class="token punctuation">,</span> clf_rbf<span class="token punctuation">,</span> clf_rbf2<span class="token punctuation">]</span>titles <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Linear Kernel'</span><span class="token punctuation">,</span>           <span class="token string">'Polynomial Kernel with Degree=3'</span><span class="token punctuation">,</span>           <span class="token string">'Gaussian Kernel with $\gamma=0.5$'</span><span class="token punctuation">,</span>           <span class="token string">'Gaussian Kernel with $\gamma=0.1$'</span><span class="token punctuation">]</span><span class="token keyword">for</span> clf<span class="token punctuation">,</span> i <span class="token keyword">in</span> zip<span class="token punctuation">(</span>clfs<span class="token punctuation">,</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>clfs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    clf<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    plot_hyperplane<span class="token punctuation">(</span>clf<span class="token punctuation">,</span> X<span class="token punctuation">,</span> y<span class="token punctuation">,</span> title<span class="token operator">=</span>titles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出的图形如下所示，其中带有 x 标记的点即为支持向量。</p><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/k_2.jpg" alt="image-20200701101406980"></p><p>左上角是线性核函数，它只能拟合出直线分隔超平面。右上角是三阶多项式核函数，它能拟合出复杂曲线分隔超平面。左下角是 <code>gamma=0.5</code> 的高斯核函数，右下角是 <code>gamma=0.1</code> 的高斯核函数，通过调整参数 <code>gamma</code> 的值，可以调整分隔超平面的形状。典型地，<code>gamma</code>值太大，越容易造成过拟合，<code>gamma</code> 值太小，高斯核函数会退化成线性核函数。我们把代码中的 <code>gamma</code>值 改为 100 和 0.01 后看一下输出图形是什么样的。</p><p>思考：左下角 gamma=0.5 的高斯核函数的图片，带有 x 标记的点是支持向量。我们之前介绍过，离分隔超平面最近的点是支持向量，为什么很多离分隔超平面很远的点，也是支持向量呢？</p><p>原因是高斯核函数把输入特征向量映射到了无限维的向量空间里，在映射后的高维向量空间里，这些点其实是离分隔超平面最近的点。当回到二维向量空间中时，这些点“看起来”就不像是距离分隔超平面最近的点了，但实际上它们就是支持向量。</p><h2 id="4-示例：乳腺癌检测"><a href="#4-示例：乳腺癌检测" class="headerlink" title="4.示例：乳腺癌检测"></a>4.示例：乳腺癌检测</h2><p>之前我们使用逻辑回归算法进行过乳腺癌检测模型的学习和训练。这里我们再使用支持向量机算法来解决这个问题。首先我们载入数据：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> train_test_split<span class="token comment" spellcheck="true"># 载入数据</span><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>datasets <span class="token keyword">import</span> load_breast_cancercancer <span class="token operator">=</span> load_breast_cancer<span class="token punctuation">(</span><span class="token punctuation">)</span>X <span class="token operator">=</span> cancer<span class="token punctuation">.</span>datay <span class="token operator">=</span> cancer<span class="token punctuation">.</span>target<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'data shape: {0}; no. positive: {1}; no. negative: {2}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>    X<span class="token punctuation">.</span>shape<span class="token punctuation">,</span> y<span class="token punctuation">[</span>y<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token punctuation">[</span>y<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>X_train<span class="token punctuation">,</span> X_test<span class="token punctuation">,</span> y_train<span class="token punctuation">,</span> y_test <span class="token operator">=</span> train_test_split<span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">,</span> test_size<span class="token operator">=</span><span class="token number">0.2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出如下：</p><pre class="line-numbers language-kotlin"><code class="language-kotlin"><span class="token keyword">data</span> shape<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token number">569</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span> no<span class="token punctuation">.</span> positive<span class="token operator">:</span> <span class="token number">357</span><span class="token punctuation">;</span> no<span class="token punctuation">.</span> negative<span class="token operator">:</span> <span class="token number">212</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看出，我们的数据集很小。高斯核函数太复杂，容易造成过拟合，模型效果应该不会太好。我们先用高斯核函数来试一下，看与我们的猜测是否一致。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>svm <span class="token keyword">import</span> SVCclf <span class="token operator">=</span> SVC<span class="token punctuation">(</span>C<span class="token operator">=</span><span class="token number">1.0</span><span class="token punctuation">,</span> kernel<span class="token operator">=</span><span class="token string">'rbf'</span><span class="token punctuation">,</span> gamma<span class="token operator">=</span><span class="token number">0.1</span><span class="token punctuation">)</span>clf<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span> y_train<span class="token punctuation">)</span>train_score <span class="token operator">=</span> clf<span class="token punctuation">.</span>score<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span> y_train<span class="token punctuation">)</span>test_score <span class="token operator">=</span> clf<span class="token punctuation">.</span>score<span class="token punctuation">(</span>X_test<span class="token punctuation">,</span> y_test<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'train score: {0}; test score: {1}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>train_score<span class="token punctuation">,</span> test_score<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出如下：</p><pre class="line-numbers language-python"><code class="language-python">train score<span class="token punctuation">:</span> <span class="token number">1.0</span><span class="token punctuation">;</span> test score<span class="token punctuation">:</span> <span class="token number">0.6491228070175439</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>训练数据集分数为1.0，交叉验证数据集分数只有0.65，这是典型的过拟合现象。这里 gamma=0.1，这个值相对已经比较小了。我们可以把gamma改的更小如0.0001看看什么结果。</p><p>当然，我们完全可以使用前面介绍过的 <code>GridSearchCV</code> 来自动选择最优参数。我们看看如果使用高斯模型，最优的gamma参数值是多少，其对应的模型交叉验证评分是多少。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> GridSearchCV<span class="token keyword">from</span> utils <span class="token keyword">import</span> plot_param_curve gammas <span class="token operator">=</span> np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0.0003</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span>param_grid <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'gamma'</span><span class="token punctuation">:</span> gammas<span class="token punctuation">}</span> clf <span class="token operator">=</span> GridSearchCV<span class="token punctuation">(</span>SVC<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> param_grid<span class="token punctuation">,</span> cv<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span>return_train_score<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>clf<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"best param: {0}\nbest score: {1}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>clf<span class="token punctuation">.</span>best_params_<span class="token punctuation">,</span>clf<span class="token punctuation">.</span>best_score_<span class="token punctuation">)</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dpi<span class="token operator">=</span><span class="token number">144</span><span class="token punctuation">)</span>plot_param_curve<span class="token punctuation">(</span>plt<span class="token punctuation">,</span> gammas<span class="token punctuation">,</span> clf<span class="token punctuation">.</span>cv_results_<span class="token punctuation">,</span> xlabel<span class="token operator">=</span><span class="token string">'gamma'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出如下：</p><pre class="line-numbers language-python"><code class="language-python">best param<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'gamma'</span><span class="token punctuation">:</span> <span class="token number">0.00011379310344827585</span><span class="token punctuation">}</span>best score<span class="token punctuation">:</span> <span class="token number">0.9367334264865704</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200701101406980.png" alt="image-20200701102906477"></p><p>由此可见，即使在最好的 gamma 参数下，其平均最优得分也只是0.9367311072056239。我们选择在gamma为0.01时，画出学习曲线，更直观地观察模型拟合情况。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> time<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> ShuffleSplitcv <span class="token operator">=</span> ShuffleSplit<span class="token punctuation">(</span>n_splits<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span> test_size<span class="token operator">=</span><span class="token number">0.2</span><span class="token punctuation">,</span> random_state<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>title <span class="token operator">=</span> <span class="token string">'Learning Curves for Gaussian Kernel'</span>start <span class="token operator">=</span> time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dpi<span class="token operator">=</span><span class="token number">144</span><span class="token punctuation">)</span>plot_learning_curve<span class="token punctuation">(</span>plt<span class="token punctuation">,</span> SVC<span class="token punctuation">(</span>C<span class="token operator">=</span><span class="token number">1.0</span><span class="token punctuation">,</span> kernel<span class="token operator">=</span><span class="token string">'rbf'</span><span class="token punctuation">,</span> gamma<span class="token operator">=</span><span class="token number">0.01</span><span class="token punctuation">)</span><span class="token punctuation">,</span> title<span class="token punctuation">,</span> X<span class="token punctuation">,</span> y<span class="token punctuation">,</span> ylim<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">1.01</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cv<span class="token operator">=</span>cv<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'elaspe: {0:.6f}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出如下：</p><pre class="line-numbers language-python"><code class="language-python">elaspe<span class="token punctuation">:</span> <span class="token number">0.687500</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>画出来的图形如下所示：</p><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/k_7.png" alt="image-20200701103141555"></p><p>这是明显的过拟合现象，交叉验证数据集的评分非常低，且离训练数据集评分非常远。</p><hr><p><strong>接下来换一个模型，使用二阶多项式核函数的SVM来拟合模型，看看结果如何。</strong></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>svm <span class="token keyword">import</span> SVCclf <span class="token operator">=</span> SVC<span class="token punctuation">(</span>C<span class="token operator">=</span><span class="token number">1.0</span><span class="token punctuation">,</span> kernel<span class="token operator">=</span><span class="token string">'poly'</span><span class="token punctuation">,</span> degree<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>clf<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span> y_train<span class="token punctuation">)</span>train_score <span class="token operator">=</span> clf<span class="token punctuation">.</span>score<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span> y_train<span class="token punctuation">)</span>test_score <span class="token operator">=</span> clf<span class="token punctuation">.</span>score<span class="token punctuation">(</span>X_test<span class="token punctuation">,</span> y_test<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'train score: {0}; test score: {1}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>train_score<span class="token punctuation">,</span> test_score<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出如下：</p><pre class="line-numbers language-python"><code class="language-python">train score<span class="token punctuation">:</span> <span class="token number">0.9098901098901099</span><span class="token punctuation">;</span> test score<span class="token punctuation">:</span> <span class="token number">0.9210526315789473</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>看起来结果好多了。作为对比，我们画出一阶多项式核函数的SVM和二阶多项式核函数的SVM的学习曲线，观察模型的拟合情况。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">import</span> timefrom sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> ShuffleSplitcv <span class="token operator">=</span> <span class="token function">ShuffleSplit</span><span class="token punctuation">(</span>n_splits<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span> test_size<span class="token operator">=</span><span class="token number">0.2</span><span class="token punctuation">,</span> random_state<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>title <span class="token operator">=</span> <span class="token string">'Learning Curves with degree={0}'</span>degrees <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span>start <span class="token operator">=</span> time<span class="token punctuation">.</span><span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span><span class="token function">figure</span><span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dpi<span class="token operator">=</span><span class="token number">144</span><span class="token punctuation">)</span><span class="token keyword">for</span> i in <span class="token keyword">range</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>degrees<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    plt<span class="token punctuation">.</span><span class="token function">subplot</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>degrees<span class="token punctuation">)</span><span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token function">plot_learning_curve</span><span class="token punctuation">(</span>plt<span class="token punctuation">,</span> <span class="token function">SVC</span><span class="token punctuation">(</span>C<span class="token operator">=</span><span class="token number">1.0</span><span class="token punctuation">,</span> kernel<span class="token operator">=</span><span class="token string">'poly'</span><span class="token punctuation">,</span> degree<span class="token operator">=</span>degrees<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                        title<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>degrees<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> X<span class="token punctuation">,</span> y<span class="token punctuation">,</span> ylim<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0.8</span><span class="token punctuation">,</span> <span class="token number">1.01</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cv<span class="token operator">=</span>cv<span class="token punctuation">,</span> n_jobs<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">'elaspe: {0:.6f}'</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出如下：</p><pre class="line-numbers language-css"><code class="language-css"><span class="token property">elaspe</span><span class="token punctuation">:</span> <span class="token number">0.281250</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出的图形如下所示：</p><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200701102906477.png" alt="image-20200701103641519"></p><p>前面我们使用逻辑回归算法来处理乳腺癌检测问题时，使用二阶多项式增加特征，同时使用L1范数作为正则项，其拟合效果比这里的支持向量机效果好。更重要的是，逻辑回归算法的运算效率远远高于二阶多项式核函数的支持向量机算法。当然，这里的支持向量机算法的效果还是比使用L2范数作为正则项的逻辑回归算法好的。由此可见，模型选择和模型参数调优，在工程实践中有着非常重要的作用的。</p><h2 id="5-拓展SVM的理解"><a href="#5-拓展SVM的理解" class="headerlink" title="5. 拓展SVM的理解"></a>5. 拓展SVM的理解</h2><h3 id="什么是-SVM-？"><a href="#什么是-SVM-？" class="headerlink" title="什么是 SVM ？"></a>什么是 SVM ？</h3><p>Support Vector Machine, 一个普通的 SVM 就是一条直线罢了，用来完美划分 linearly separable 的两类。但这又不是一条普通的直线，这是无数条可以分类的直线当中最完美的，因为它恰好在两个类的中间，距离两个类的点都一样远。而所谓的 Support vector 就是这些离分界线最近的『点』。如果去掉这些点，直线多半是要改变位置的。可以说是这些 vectors （主，点点） support （谓，定义）了 machine （宾，分类器）…</p><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/k_8.png" alt="k_2" title="k_2"></p><p>所以谜底就在谜面上啊朋友们，只要找到了这些最靠近的点不就找到了 SVM 了嘛。</p><p>如果是高维的点，SVM 的分界线就是平面或者超平面。其实没有差，都是一刀切两块，我就统统叫直线了。</p><h3 id="怎么求解-SVM-？"><a href="#怎么求解-SVM-？" class="headerlink" title="怎么求解 SVM ？"></a>怎么求解 SVM ？</h3><p>关于这条直线，我们知道 </p><p>(1)它离两边一样远，(2)最近距离就是到support vector的距离，其他距离只能更远。</p><p>于是自然而然可以得到重要表达 <b>I. direct representation</b></p><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200701103141555.png" alt="k_7" title="k_7"></p><p>（可以把 margin 看作是 boundary 的函数，并且想要找到使得是使得 margin 最大化的boundary，而 margin(*) 这个函数是: 输入一个 boundary ，计算（正确分类的）所有苹果和香蕉中，到 boundary 的最小距离。）</p><p>又有最大又有最小看起来好矛盾。实际上『最大』是对这个整体使用不同 boundary 层面的最大，『最小』是在比较『点』的层面上的最小。外层在比较 boundary 找最大的 margin ，内层在比较点点找最小的距离。</p><p>其中距离，说白了就是点到直线的距离；只要定义带正负号的距离，是 {苹果+1} 面为正 {香蕉-1} 面为负的距离，互相乘上各自的 label <img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200701103641519.png" alt="k_8" title="k_8"> ，就和谐统一民主富强了。</p><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/k_9.png" alt="k_9" title="k_9"></p><p>到这里为止已经说完了所有关于SVM的直观了解，如果不想看求解，可以跳过下面一大段直接到 objective function 。</p><p>直接表达虽然清楚但是求解无从下手。做一些简单地等价变换（分母倒上来）可以得到 <b>II. canonical representation </b> （敲黑板）</p><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/k_10.png" alt="k_10" title="k_10"></p><p>要得到 <b>III. dual representation</b> 之前需要大概知道一下拉格朗日乘子法 (method of lagrange multiplier)，它是用在有各种约束条件(各种 “subject to” )下的目标函数，也就是直接可以求导可以引出 dual representation（怎么还没完摔）</p><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/k_11.png" alt="k_11" title="k_11"></p><p>稍微借用刚刚数学表达里面的内容看个有趣的东西: </p><p>还记得我们怎么预测一个新的水果是苹果还是香蕉吗？我们代入到分界的直线里，然后通过符号来判断。</p><p>刚刚w已经被表达出来了也就是说这个直线现在变成了:  <img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/k_12.png" alt="k_12" title="k_12"></p><p>看似仿佛用到了所有的训练水果，但是其中 <img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/k_13.png" alt="k_13" title="k_13"> 的水果都没有起到作用，剩下的就是小部分靠边边的 Support vectors 呀。</p><p><b>III. dual representation</b></p><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/k_14.png" alt="k_14" title="k_14"></p><p><b>如果香蕉和苹果不能用直线分割呢？</b></p><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/k_15.png" alt="k_3" title="k_3"></p><p>Kernel trick. </p><p>其实用直线分割的时候我们已经使用了 kernel ，那就是线性 kernel , <img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/k_3.jpg" alt="k_15" title="k_15"></p><p>如果要替换 kernel 那么把目标函数里面的内积全部替换成新的 kernel function 就好了，就是这么简单。</p><p>第一个武侠大师的比喻已经说得很直观了，低维非线性的分界线其实在高维是可以线性分割的，可以理解为——『你们是虫子！』分得开个p…（大雾）</p><p><b>如果香蕉和苹果有交集呢？</b></p><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/k_4.jpg" alt="k_4" title="k_4"></p><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/k_16.png" alt="k_16" title="k_16"></p><p><b>如果还有梨呢？</b></p><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/k_5.jpg" alt="k_5" title="k_5"></p><p>可以每个类别做一次 SVM: 是苹果还是不是苹果？是香蕉还是不是香蕉？是梨子还是不是梨子？从中选出可能性最大的。这是 one-versus-the-rest approach。</p><p>也可以两两做一次 SVM: 是苹果还是香蕉？是香蕉还是梨子？是梨子还是苹果？最后三个分类器投票决定。这是 one-versus-one approace。</p><p>但这其实都多多少少有问题，比如苹果特别多，香蕉特别少，我就无脑判断为苹果也不会错太多；多个分类器要放到一个台面上，万一他们的 scale 没有在一个台面上也未可知。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> ML算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>emoji test</title>
      <link href="/2020/06/30/emoji-test/"/>
      <url>/2020/06/30/emoji-test/</url>
      
        <content type="html"><![CDATA[<p>啊实打实大萨达萨达</p><p>:smile:</p><p>:smile:</p><p>:smile:</p><p>:rainbow:</p><p>:rainbow: asdasdasdasdasdasd</p><h3 id="rainbow-asdasdasdasdasdasd"><a href="#rainbow-asdasdasdasdasdasd" class="headerlink" title=":rainbow: asdasdasdasdasdasd"></a>:rainbow: asdasdasdasdasdasd</h3><p>emoji  速查<a href="https://www.webfx.com/tools/emoji-cheat-sheet/" target="_blank" rel="noopener">https://www.webfx.com/tools/emoji-cheat-sheet/</a></p><h2 id="出现代码块，emoji-显示异常"><a href="#出现代码块，emoji-显示异常" class="headerlink" title="出现代码块，emoji 显示异常"></a>出现代码块，emoji 显示异常</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>datasets <span class="token keyword">import</span> load_breast_cancercancer <span class="token operator">=</span> load_breast_cancer<span class="token punctuation">(</span><span class="token punctuation">)</span>X <span class="token operator">=</span> cancer<span class="token punctuation">.</span>datay <span class="token operator">=</span> cancer<span class="token punctuation">.</span>target<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'data shape: {0}; no. positive: {1}; no. negative: {2}'</span>      <span class="token punctuation">.</span>format<span class="token punctuation">(</span>X<span class="token punctuation">.</span>shape<span class="token punctuation">,</span>y<span class="token punctuation">[</span>y<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>y<span class="token punctuation">[</span>y<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>cancer<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scikit-learn系列五：决策树</title>
      <link href="/2020/06/30/scikit-learn-xi-lie-wu-jue-ce-shu/"/>
      <url>/2020/06/30/scikit-learn-xi-lie-wu-jue-ce-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="项目地址传送门，欢迎-star-和-fork-！"><a href="#项目地址传送门，欢迎-star-和-fork-！" class="headerlink" title="项目地址传送门，欢迎 star 和 fork ！"></a>项目地址<a href="https://github.com/DongZhouGu/scikit-learn-ml" target="_blank" rel="noopener">传送门</a>，欢迎 star 和 fork ！</h2><h2 id="1-决策树概述"><a href="#1-决策树概述" class="headerlink" title="1. 决策树概述"></a>1. 决策树概述</h2><p>决策树（Decision Tree）算法是一种基本的分类与回归方法，是最经常使用的数据挖掘算法之一，它的预测结果容易理解，易于向业务部门解释，预测速度快，可以处理离散型数据和连续型数据。</p><p>决策树模型呈树形结构，在分类问题中，表示基于特征对实例进行分类的过程。它可以认为是 if-then 规则的集合，也可以认为是定义在特征空间与类空间上的条件概率分布。</p><p>决策树学习通常包括 3 个步骤: 特征选择、决策树的生成和决策树的修剪。</p><hr><h2 id="2-决策树原理"><a href="#2-决策树原理" class="headerlink" title="2. 决策树原理"></a>2. 决策树原理</h2><p>一个叫做 “二十个问题” 的游戏，游戏的规则很简单: 参与游戏的一方在脑海中想某个事物，其他参与者向他提问，只允许提 20 个问题，问题的答案也只能用对或错回答。问问题的人通过推断分解，逐步缩小待猜测事物的范围，最后得到游戏的答案。</p><p>一个邮件分类系统，大致工作流程如下: </p><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/%E5%86%B3%E7%AD%96%E6%A0%91-%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt="决策树-流程图" title="决策树示例流程图"></p><pre><code>首先检测发送邮件域名地址。如果地址为 myEmployer.com, 则将其放在分类 "无聊时需要阅读的邮件"中。如果邮件不是来自这个域名，则检测邮件内容里是否包含单词 "曲棍球" , 如果包含则将邮件归类到 "需要及时处理的朋友邮件", 如果不包含则将邮件归类到 "无需阅读的垃圾邮件" 。</code></pre><p>问题来了，在创建决策树的过程中，要先对哪个特征进行分裂？比如上图中的例子，先判断域名地址进行分裂还是先判断包含 “曲棍球” 进行分裂？要回答这个问题，我们需要从信息的量化谈起。</p><h3 id="2-1-信息熵-amp-信息增益"><a href="#2-1-信息熵-amp-信息增益" class="headerlink" title="2.1 信息熵 &amp; 信息增益"></a>2.1 信息熵 &amp; 信息增益</h3><p><code>熵（entropy）:</code><br>熵指的是体系的混乱的程度，在不同的学科中也有引申出的更为具体的定义，是各领域十分重要的参量。</p><p><code>信息论（information theory）中的熵（香农熵）:</code><br>是一种信息的度量方式，表示信息的混乱程度，也就是说: 信息越有序，信息熵越低。例如: 火柴有序放在火柴盒里，熵值很低，相反，熵值很高。</p><p><code>信息增益（information gain）:</code><br>在划分数据集前后信息发生的变化称为信息增益。</p><h3 id="2-2-决策树的创建"><a href="#2-2-决策树的创建" class="headerlink" title="2.2 决策树的创建"></a>2.2 决策树的创建</h3><p>决策树的构建过程，就是从训练数据集中归纳出一组分类规则，使它与训练数据矛盾较小的同时具有较强的泛化能力。有了信息增益来量化地选择数据集的划分特征，使决策树的创建过程变得容易了。决策树的创建基本上分为以下几个步骤：</p><p> （1）计算数据集划分前的信息熵。<br> （2）遍历所有未作为划分条件的特征，分别计算根据每个特征划分数据集后的信息熵。<br> （3）选择信息增益最大的特征，并使用这个特征作为数据划分节点来划分数据。<br> （4）递归地处理被划分后的所有子数据集，从未被选择的特征里继续选择最优数据划分特征来划分子数据集。</p><p>问题来了，递归过程什么时候结束呢？一般来讲，有两个终止条件：一是所有的特征都用完了，即没有新的特征可以用来进一步划分数据集。二是划分后的信息增益足够小了，这个时候就可以停止递归划分了。针对这个停止条件，需要事先选择信息增益的阈值来作为结束递归地条件。</p><p>使用信息增益作为特征选择指标的决策树构建算法，称为ID3算法。</p><h3 id="2-3-剪枝算法"><a href="#2-3-剪枝算法" class="headerlink" title="2.3 剪枝算法"></a>2.3 剪枝算法</h3><p>使用决策树模型拟合数据时，容易造成过拟合。解决过拟合的方法是对决策树进行剪枝处理。决策树的剪枝有两种思路：前剪枝（Pre-Pruning）和后剪枝（Post-Pruning）。</p><h4 id="前剪枝（Pre-Pruning）"><a href="#前剪枝（Pre-Pruning）" class="headerlink" title="前剪枝（Pre-Pruning）"></a>前剪枝（Pre-Pruning）</h4><p> 前剪枝是在构造决策树的同时进行剪枝。在决策树的构建过程中，如果无法进一步降低信息熵，就会停止创建分支。为了避免过拟合，可以设定一个阈值，即使可以继续降低信息熵，也停止继续创建分支。这种方法称为前剪枝。还有一些简单的前剪枝方法，如限制叶子节点的样本个数，当样本个数小于一定的阈值时，即不再继续创建分支。</p><h4 id="后剪枝（Post-Pruning）"><a href="#后剪枝（Post-Pruning）" class="headerlink" title="后剪枝（Post-Pruning）"></a>后剪枝（Post-Pruning）</h4><p> 后剪枝是指决策树构建完成之后进行剪枝。剪枝的过程是对拥有同样父节点的一组节点进行检查，判断如果将其合并，信息熵的增加量是否小于某一阈值。如果小于阈值，则这一组节点可以合并成一个节点。后剪枝是目前较普遍的做法。后剪枝的过程是删除一些子树，然后用子树的根节点代替，来作为新的叶子结点。这个新的叶子节点所标识的类别通过大多数原则来确定，即把这个叶子节点里样本最多的类别，作为这个叶子节点的类别。</p><p>后剪枝算法有很多种，其中常用的一种称为 <code>降低错误率剪枝法（Reduced-Error Pruning）</code>。其思路是，自底向上，从已经构建好的完全决策树中找出一棵子树，然后用子树的根代替这棵子树，作为新的叶子节点。叶子节点所标识的类别通过大多数原则来确定。这样就构建出了一个新的简化版的决策树。然后使用交叉验证数据集来检测这棵简化版的决策树，看其错误率是否降低了。如果错误率降低了，则可以使用这个简化版的决策树代替完全决策树。否则，还是采用原来的决策树。通过遍历所有的子树，直到针对交叉验证数据集，无法进一步降低错误率为止。</p><hr><h2 id="3-决策树算法参数"><a href="#3-决策树算法参数" class="headerlink" title="3. 决策树算法参数"></a>3. 决策树算法参数</h2><p><code>scikit-learn</code>使用 <code>sklearn.tree.DecisionTreeClassifier</code> 类来实现决策树分类算法。其中几个典型的参数如下：</p><ul><li><code>criterion：特征选择算法。</code>一种是基于信息熵，另外一种是基于基尼不纯度。研究表明，这两种算法的差异性不大，对模型准确性没有太大的影响。相对而言，信息熵运算效率会低一些，因为它有对数运算。</li><li><code>splitter：创建决策树分支的选项。</code>一种是选择最优的分支创建原则。另外一种是从排名靠前的特征中，随机选择一个特征来创建分支，这个方法和正则项的效果类似，可以避免过拟合。</li><li><code>max_depth：</code>指定决策树的最大深度。通过指定该参数，用来解决模型过拟合问题。</li><li><code>min_samples_split：</code>这个参数指定能创建分支的数据集的大小，默认是2。如果一个节点的数据样本个数小于这个数值，则不再创建分支。这就是上面介绍的前剪枝的一种方法。</li><li><code>min_samples_leaf：</code>叶子节点的最小样本数量，叶子节点的样本数量必须大于等于这个值。这也是上面介绍的另一种前剪枝的方法。</li><li><code>max_leaf_nodes：</code>最大叶子节点个数，即数据集最多能划分成几个类别。</li><li><code>min_impurity_split：</code>信息增益必须大于等于这个阈值才可以继续分支，否则不创建分支。<br> 从这些参数可以看出，<code>scikit-learn</code>有一系列的参数用来控制决策树的生成过程，从而解决过拟合问题。</li></ul><hr><h2 id="4-示例：预测泰坦尼克号幸存者"><a href="#4-示例：预测泰坦尼克号幸存者" class="headerlink" title="4. 示例：预测泰坦尼克号幸存者"></a>4. 示例：预测泰坦尼克号幸存者</h2><p>众所周知，泰坦尼克号是历史上最严重的一起海难事故。我们通过决策树模型，来预测哪些人可能成为幸存者。<a href="https://www.kaggle.com/c/titanic" target="_blank" rel="noopener">数据集下载</a>，也可以去<a href="https://github.com/DongZhouGu/scikit-learn-ml" target="_blank" rel="noopener">仓库地址</a></p><p>数据集中总共有两个文件，都是 csv 格式的数据。其中，train.csv 是训练数据集，包含已标注的训练样本数据。test.csv 是模型进行幸存者预测的测试数据。我们的任务就是根据 train.csv 里的数据训练出决策树模型，然后使用该模型来预测test.csv里的数据，并查看模型的预测效果。</p><h3 id="4-1-数据分析"><a href="#4-1-数据分析" class="headerlink" title="4.1 数据分析"></a>4.1 数据分析</h3><p>train.csv 是一个892行、12列的数据表格。意味着我们有 891 个训练样本（扣除表头），每个样本有12个特征。我们需要先分析这些特征，以便决定哪些特征可以用来进行模型训练。</p><ul><li><code>PassengerId：</code>乘客的ID号，这个是顺序编号，用来唯一地标识一名乘客。这个特征和幸存与否无关，丢弃这个特征。</li><li><code>Survived</code>：1表示幸存，0表示遇难。这是标注数据。</li><li><code>Pclass</code>：仓位等级。这是个很重要的特征，高仓位的乘客能更快的到达甲板，从而更容易获救。</li><li><code>Name</code>：乘客的名字，这个特征和幸存与否无关，丢弃这个特征。</li><li><code>Sex</code>：乘客性别。由于救生艇数量不够，船长让妇女和儿童先上救生艇。所以这也是个很重要的特征。</li><li><code>Age</code>：乘客的年龄。儿童会优先上救生艇，身强力壮者幸存概率也会高一些。所以这也是个很重要的特征。</li><li><code>SibSp</code>：兄弟姐妹同在船上的数量。</li><li><code>Parch</code>：同船的父辈人员的数量。</li><li><code>Ticket</code>：乘客的票号。这个特征和幸存与否无关，丢弃这个特征。</li><li><code>Fare</code>：乘客的体热指标。</li><li><code>Cabin</code>：乘客所在的船舱号。实际上这个特征和幸存与否有一定的关系，比如最早被水淹没的船舱位置，其乘客的幸存概率要低一些。但由于这个特征有大量的丢失数据，而且没有更多的数据来对船舱进行归类，因此我们丢弃这个特征的数据。</li><li><code>Embarked</code>：乘客登船的港口。我们需要把港口数据转换为数值类型的数据。</li></ul><p>我们需要加载csv数据。并做一些预处理，包括：</p><ul><li>提取Survived列的数据作为模型的标注数据。</li><li>丢弃不需要的特征数据。</li><li>对数据进行转换，以便模型处理。比如把性别数据转换为0和1.</li><li>处理缺失的数据。比如年龄这个特征，有很多缺失的数据。</li></ul><p><code>Pandas</code> 是完成这些任务的理想软件包，我们先把数据从文件里读取出来：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token keyword">def</span> <span class="token function">read_dataset</span><span class="token punctuation">(</span>fname<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 指定第一列作为行索引</span>    data <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span>fname<span class="token punctuation">,</span>index_col<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 丢弃无用的数据</span>    data<span class="token punctuation">.</span>drop<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'Name'</span><span class="token punctuation">,</span><span class="token string">'Ticket'</span><span class="token punctuation">,</span><span class="token string">'Cabin'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>inplace<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 处理性别数据</span>    data<span class="token punctuation">[</span><span class="token string">'Sex'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token string">'Sex'</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'male'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>astype<span class="token punctuation">(</span><span class="token string">'int'</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 处理登船港口数据</span>    labels <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token string">'Embarked'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>unique<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span>    data<span class="token punctuation">[</span><span class="token string">'Embarked'</span><span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token string">'Embarked'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>apply<span class="token punctuation">(</span><span class="token keyword">lambda</span> n<span class="token punctuation">:</span>labels<span class="token punctuation">.</span>index<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 处理缺失数据</span>    data <span class="token operator">=</span> data<span class="token punctuation">.</span>fillna<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> datatrain <span class="token operator">=</span> read_dataset<span class="token punctuation">(</span><span class="token string">'./titanic/train.csv'</span><span class="token punctuation">)</span>train<span class="token punctuation">.</span>head<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>处理完的数据如下：</p><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200630171531856.png" alt="img"></p><h3 id="4-2-模型训练"><a href="#4-2-模型训练" class="headerlink" title="4.2 模型训练"></a>4.2 模型训练</h3><p>首先需要把 <code>Survived</code> 列提取出来作为标签，并在原数据集中删除这一列。然后把数据集划分成训练数据集和交叉验证数据集。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> train_test_splity <span class="token operator">=</span> train<span class="token punctuation">[</span><span class="token string">'Survived'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>valuesX <span class="token operator">=</span> train<span class="token punctuation">.</span>drop<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'Survived'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>valuesX_train<span class="token punctuation">,</span>X_test<span class="token punctuation">,</span>y_train<span class="token punctuation">,</span>y_test <span class="token operator">=</span> train_test_split<span class="token punctuation">(</span>X<span class="token punctuation">,</span>y<span class="token punctuation">,</span>test_size<span class="token operator">=</span><span class="token number">0.2</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'train dataset: {0}; test dataset: {1}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>X_train<span class="token punctuation">.</span>shape<span class="token punctuation">,</span>X_test<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出如下：</p><pre class="line-numbers language-python"><code class="language-python">train dataset<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token number">712</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span> test dataset<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token number">179</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接着，使用 <code>scikit-learn</code> 的决策树模型对数据集进行拟合，并观察模型的性能：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>tree <span class="token keyword">import</span> DecisionTreeClassifierclf <span class="token operator">=</span> DecisionTreeClassifier<span class="token punctuation">(</span><span class="token punctuation">)</span>clf<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span>y_train<span class="token punctuation">)</span>train_score <span class="token operator">=</span> clf<span class="token punctuation">.</span>score<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span>y_train<span class="token punctuation">)</span>test_score <span class="token operator">=</span> clf<span class="token punctuation">.</span>score<span class="token punctuation">(</span>X_test<span class="token punctuation">,</span>y_test<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'train score: {0}; test score: {1}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>train_score<span class="token punctuation">,</span>test_score<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出如下：</p><pre class="line-numbers language-python"><code class="language-python">train score<span class="token punctuation">:</span> <span class="token number">0.9859550561797753</span><span class="token punctuation">;</span> test score<span class="token punctuation">:</span> <span class="token number">0.7877094972067039</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>从输出结果可以看出，针对训练样本评分很高，但是针对交叉验证数据集评分较低，两者差距较大。没错，这是过拟合现象。解决决策树过拟合的方法是剪枝，包括前剪枝和后剪枝。不幸的是 <code>scikit-learn</code> 不支持后剪枝，但是提供了一系列模型参数进行前剪枝。例如，可以通过 <code>max_depth</code> 参数限定决策树的深度，当决策树达到限定的深度时，就不再进行分裂了。这样就可以在一定程度上避免过拟合。</p><h3 id="4-3-优化模型参数"><a href="#4-3-优化模型参数" class="headerlink" title="4.3 优化模型参数"></a>4.3 优化模型参数</h3><p>我们可以选择一系列的参数值，然后分别计算指定参数训练出来的模型的评分。还可以把参数值和模型评分通过图形画出来，以便直观地发现两者之间的关系。</p><p>这里以限制决策树深度 <code>max_depth</code> 为了来介绍模型参数的优化过程。我们先创建一个函数，它使用不同的<code>max_depth</code> 来训练模型，并计算模型评分。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 参数选择 max_depth</span><span class="token keyword">def</span> <span class="token function">cv_score</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">:</span>    clf <span class="token operator">=</span> DecisionTreeClassifier<span class="token punctuation">(</span>max_depth<span class="token operator">=</span>d<span class="token punctuation">)</span>    clf<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span>y_train<span class="token punctuation">)</span>    tr_score <span class="token operator">=</span> clf<span class="token punctuation">.</span>score<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span>y_train<span class="token punctuation">)</span>    cv_score <span class="token operator">=</span> clf<span class="token punctuation">.</span>score<span class="token punctuation">(</span>X_test<span class="token punctuation">,</span>y_test<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>tr_score<span class="token punctuation">,</span>cv_score<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着构造参数范围，在这个范围内分别计算模型评分，并找出评分最高的模型所对应的参数。</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">import</span> numpy <span class="token operator">as</span> npdepths <span class="token operator">=</span> <span class="token function">range</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">)</span>scores <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token function">cv_score</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token keyword">for</span> d <span class="token keyword">in</span> depths<span class="token punctuation">]</span>tr_scores <span class="token operator">=</span> <span class="token punctuation">[</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">for</span> s <span class="token keyword">in</span> scores<span class="token punctuation">]</span>cv_scores <span class="token operator">=</span> <span class="token punctuation">[</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">for</span> s <span class="token keyword">in</span> scores<span class="token punctuation">]</span>best_score_index <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token function">argmax</span><span class="token punctuation">(</span>cv_scores<span class="token punctuation">)</span>best_score <span class="token operator">=</span> cv_scores<span class="token punctuation">[</span>best_score_index<span class="token punctuation">]</span>best_param <span class="token operator">=</span> depths<span class="token punctuation">[</span>best_score_index<span class="token punctuation">]</span><span class="token function">print</span><span class="token punctuation">(</span>scores<span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">'best param: {0}； best score： {1}'</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>best_param<span class="token punctuation">,</span>best_score<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出如下：</p><pre class="line-numbers language-css"><code class="language-css">best <span class="token property">param</span><span class="token punctuation">:</span> <span class="token number">4</span>； best score： <span class="token number">0.8212290502793296</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到，针对模型深度这个参数，最优的值是4，其对应的交叉验证数据集评分为0.82。我们还可以把模型参数和对应的模型评分画出来，更直观地观察其变化规律。</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token operator">as</span> pltplt<span class="token punctuation">.</span><span class="token function">figure</span><span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>dpi<span class="token operator">=</span><span class="token number">144</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span><span class="token function">grid</span><span class="token punctuation">(</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span><span class="token function">xlabel</span><span class="token punctuation">(</span><span class="token string">'max depth of decision tree'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span><span class="token function">ylabel</span><span class="token punctuation">(</span><span class="token string">'score'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span><span class="token function">plot</span><span class="token punctuation">(</span>depths<span class="token punctuation">,</span>cv_scores<span class="token punctuation">,</span><span class="token string">'.g-'</span><span class="token punctuation">,</span>label<span class="token operator">=</span><span class="token string">'cross-validation score'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span><span class="token function">plot</span><span class="token punctuation">(</span>depths<span class="token punctuation">,</span>tr_scores<span class="token punctuation">,</span><span class="token string">'.r--'</span><span class="token punctuation">,</span>label<span class="token operator">=</span><span class="token string">'training score'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span><span class="token function">legend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出如下：</p><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/17634123-8536c1c2cfda1d0f.png" alt="image-20200630171531856"></p><p>使用同样的方式，我们可以考察参数 m<code>in_impurity_split</code> 。这个参数用来指定信息熵或基尼不纯度的阈值。当决策树分裂后，其信息增益低于这个阈值，则不再分裂。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 训练模型，并计算评分</span><span class="token keyword">def</span> <span class="token function">cv_score</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">:</span>    clf <span class="token operator">=</span> DecisionTreeClassifier<span class="token punctuation">(</span>criterion<span class="token operator">=</span><span class="token string">'gini'</span><span class="token punctuation">,</span> min_impurity_decrease<span class="token operator">=</span>val<span class="token punctuation">)</span>    clf<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span> y_train<span class="token punctuation">)</span>    tr_score <span class="token operator">=</span> clf<span class="token punctuation">.</span>score<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span> y_train<span class="token punctuation">)</span>    cv_score <span class="token operator">=</span> clf<span class="token punctuation">.</span>score<span class="token punctuation">(</span>X_test<span class="token punctuation">,</span> y_test<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>tr_score<span class="token punctuation">,</span> cv_score<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 指定参数范围，分别训练模型，并计算评分</span>values <span class="token operator">=</span> np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0.005</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span>scores <span class="token operator">=</span> <span class="token punctuation">[</span>cv_score<span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token keyword">for</span> v <span class="token keyword">in</span> values<span class="token punctuation">]</span>tr_scores <span class="token operator">=</span> <span class="token punctuation">[</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">for</span> s <span class="token keyword">in</span> scores<span class="token punctuation">]</span>cv_scores <span class="token operator">=</span> <span class="token punctuation">[</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">for</span> s <span class="token keyword">in</span> scores<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 找出评分最高的模型参数</span>best_score_index <span class="token operator">=</span> np<span class="token punctuation">.</span>argmax<span class="token punctuation">(</span>cv_scores<span class="token punctuation">)</span>best_score <span class="token operator">=</span> cv_scores<span class="token punctuation">[</span>best_score_index<span class="token punctuation">]</span>best_param <span class="token operator">=</span> values<span class="token punctuation">[</span>best_score_index<span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'best param: {0}; best score: {1}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>best_param<span class="token punctuation">,</span> best_score<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 画出模型参数与模型评分的关系</span>plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dpi<span class="token operator">=</span><span class="token number">144</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>grid<span class="token punctuation">(</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'threshold of entropy'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'score'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>values<span class="token punctuation">,</span> cv_scores<span class="token punctuation">,</span> <span class="token string">'.g-'</span><span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'cross-validation score'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>values<span class="token punctuation">,</span> tr_scores<span class="token punctuation">,</span> <span class="token string">'.r--'</span><span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'training score'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出如下：</p><pre class="line-numbers language-python"><code class="language-python">best param<span class="token punctuation">:</span> <span class="token number">0.0005102040816326531</span><span class="token punctuation">;</span> best score<span class="token punctuation">:</span> <span class="token number">0.8100558659217877</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200630181702264.png" alt="image-20200630174835975"></p><p>这里把[0,0.005]等分50份，以每个等分点作为信息增益阈值来训练一次模型。可以看到，训练数据集的评分急速下降，且训练评分和测试评分都保持较低水平，说明模型欠拟合。我们可以把决策树特征选择的基尼不纯度改为信息熵，即把参数<code>criterion</code>的值改为<code>'entropy'</code>观察图形的变化。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>clf <span class="token operator">=</span> DecisionTreeClassifier<span class="token punctuation">(</span>criterion<span class="token operator">=</span><span class="token string">'entropy'</span><span class="token punctuation">,</span> min_impurity_decrease<span class="token operator">=</span>val<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200630174835975.png" alt="image-20200630175057127"></p><h3 id="4-4-模型参数选择工具包"><a href="#4-4-模型参数选择工具包" class="headerlink" title="4.4 模型参数选择工具包"></a>4.4 模型参数选择工具包</h3><p>上面的模型参数优化过程存在两个问题。其一，数据不稳定，即数据集每次都是随机划分的，选择出来的最优参数在下一次运行时就不是最优的了。其二，不能一次选择多个参数，例如，想要考察 <code>max_depth</code>和<code>min_samples_leaf</code>两个结合起来的最优参数就无法实现。</p><p>问题一的原因是，每次把数据集划分为训练样本和交叉验证样本时，是随机划分的，这样导致每次的训练数据集是有差异的，训练出来的模型也有差异。解决这个问题的方法是多次计算，求平均值。具体来讲，就是针对模型的某个特定的参数，多次划分数据集，多次训练模型，计算出这个参数对应的模型的最低评分、最高评分以及评价评分。问题二的解决办法比较简单，把代码再优化一下，能处理多个参数组合即可。</p><p>所幸，我们不需要从头实现这些代码。<code>scikit-learn</code>在 <code>sklearn.model_selection</code>包里提供了大量模型选择和评估工具供我们使用。针对以上问题，可以使用 <code>GridSearchCV</code> 类来解决。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> GridSearchCVthresholds <span class="token operator">=</span> np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span>param_grid <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'min_impurity_split'</span><span class="token punctuation">:</span> thresholds<span class="token punctuation">}</span>clf <span class="token operator">=</span> GridSearchCV<span class="token punctuation">(</span>DecisionTreeClassifier<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> param_grid<span class="token punctuation">,</span> cv<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span>return_train_score<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>clf<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"best param: {0}\nbest score: {1}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>clf<span class="token punctuation">.</span>best_params_<span class="token punctuation">,</span> clf<span class="token punctuation">.</span>best_score_<span class="token punctuation">)</span><span class="token punctuation">)</span>plot_curve<span class="token punctuation">(</span>thresholds<span class="token punctuation">,</span> clf<span class="token punctuation">.</span>cv_results_<span class="token punctuation">,</span> xlabel<span class="token operator">=</span><span class="token string">'gini thresholds'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出如下：</p><pre class="line-numbers language-python"><code class="language-python">best param<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'min_impurity_split'</span><span class="token punctuation">:</span> <span class="token number">0.19387755102040816</span><span class="token punctuation">}</span>best score<span class="token punctuation">:</span> <span class="token number">0.82045069361622</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其中关键的参数是<code>param_grid</code>，它是一个字典，键对应的值是一个列表。<code>GridSearchCV</code>会枚举列表里的所有值来构建模型，最终得出指定参数值的平均评分及标准差。另外一个关键参数是cv，它用来指定交叉验证数据集的生成规则，代码中的 cv=5 ，表示每次计算都把数据集分成 5 份，拿其中一份作为交叉验证数据集，其他的作为训练数据集。最终得出的最优参数及最优评分保存在 <code>clf.best_params</code> 和 <code>clf.best_score</code>里。此外，<code>clf.cv_results_</code>保存了计算过程的所有中间结果。我们可以拿这个数据来画出模型参数与模型评分的关系图，如下所示:</p><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200630175057127.png" alt="image-20200630181702264"></p><p>接下来看一下如何在多组参数之间选择最优的参数组合：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> GridSearchCVentropy_thresholds <span class="token operator">=</span> np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">)</span>gini_thresholds <span class="token operator">=</span> np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0.5</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">)</span>param_grid <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token string">'criterion'</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'entropy'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'min_impurity_split'</span><span class="token punctuation">:</span>entropy_thresholds<span class="token punctuation">}</span><span class="token punctuation">,</span>              <span class="token punctuation">{</span><span class="token string">'criterion'</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'gini'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'min_impurity_split'</span><span class="token punctuation">:</span>gini_thresholds<span class="token punctuation">}</span><span class="token punctuation">,</span>              <span class="token punctuation">{</span><span class="token string">'max_depth'</span><span class="token punctuation">:</span>range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span>              <span class="token punctuation">{</span><span class="token string">'min_samples_split'</span><span class="token punctuation">:</span>range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">]</span>clf<span class="token operator">=</span>GridSearchCV<span class="token punctuation">(</span>DecisionTreeClassifier<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>param_grid<span class="token punctuation">,</span>cv<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span>clf<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'best param: {0}\nbest score: {1}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>clf<span class="token punctuation">.</span>best_params_<span class="token punctuation">,</span>clf<span class="token punctuation">.</span>best_score_<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出如下：</p><pre class="line-numbers language-python"><code class="language-python">best param<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'criterion'</span><span class="token punctuation">:</span> <span class="token string">'entropy'</span><span class="token punctuation">,</span> <span class="token string">'min_impurity_split'</span><span class="token punctuation">:</span> <span class="token number">0.5306122448979591</span><span class="token punctuation">}</span>best score<span class="token punctuation">:</span> <span class="token number">0.8305818843763729</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>代码关键部分还是<code>param_grid</code>参数，它是一个列表，列表中的每个元素都是字典。例如：针对列表中的第一个字典，选择信息熵作为决策树特征选择的判断标准，同时其阈值范围是[0,1]之间分了50等份。<code>GridSearchCV</code>会针对列表中的每个字典进行迭代，最终比较列表中每个字典所对应的参数组合，选择出最优的参数。关于<code>GridSearchCV</code>的更多详情可参考<a href="http://lijiancheng0614.github.io/scikit-learn/modules/generated/sklearn.grid_search.GridSearchCV.html" target="_blank" rel="noopener">官方文档</a>。</p><p>最后基于好奇，使用最优参数的决策树到底是什么样呢？我们可以使用 <code>sklearn.tree.export_graphviz()</code> 函数把决策树模型导出到文件中，然后使用<code>graphviz</code>工具包生成决策树示意图。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>tree <span class="token keyword">import</span> export_graphvizcolumns <span class="token operator">=</span> train<span class="token punctuation">.</span>columns<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 导出 titanic.dot 文件</span><span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">"E:/titanic.dot"</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    f <span class="token operator">=</span> export_graphviz<span class="token punctuation">(</span>clf<span class="token punctuation">,</span> out_file<span class="token operator">=</span>f<span class="token punctuation">,</span>feature_names<span class="token operator">=</span>columns<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 1. conda安装 graphviz ：conda install python-graphviz </span><span class="token comment" spellcheck="true"># 2. 运行 `dot -Tpdf titanic.dot -o titanic.pdf` </span><span class="token comment" spellcheck="true"># 3. 在当前目录查看生成的决策树 titanic.png</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最优参数的决策树就长这个样子</p><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200630185703496.png" alt="image-20200630185703496"></p><hr><h2 id="5-集合算法"><a href="#5-集合算法" class="headerlink" title="5.集合算法"></a>5.集合算法</h2><p>集合算法（Ensemble）是一种元算法（Meta-algorithm），它利用统计学采样原理，训练出成百上千个不同的算法模型。当需要预测一个新样本时，使用这些模型分别对这个样本进行预测，然后采样少数服从多数的原则，决定新样本的类别。集合算法可以有效地解决过拟合问题。在scikit-learn 里，所有的集合算法都实现在<code>sklearn.ensemble</code>包里。</p><h3 id="5-1-自助聚合算法Bagging"><a href="#5-1-自助聚合算法Bagging" class="headerlink" title="5.1 自助聚合算法Bagging"></a>5.1 自助聚合算法Bagging</h3><p>自助聚合（Bagging，Bootstrap Aggregating的缩写）的核心思想是，采用有放回的采样规则，从m个样本的原数据集里进行n次采样（n&lt;=m），构成一个包含n个样本的新训练数据集。重复这个过程B次，得到B个模型，当有新样本需要预测时，拿这B个模型分别对这个样本进行预测，然后采用投票方式（回归问题）得到新样本的预测值。</p><p>所谓的有放回采样规则是指，在m个数据集里，随机取出一个样本放到新数据集里，然后把这个样本放回到原数据集里，继续随机采样，直到到达采样次数n为止。由此可见，随机采样出的数据集里可能有重复数据，并且原数据集的每一个数据不一定都出现在新数据集里。</p><p>单一模型往往容易对数据噪声敏感，从而造成高方差（High Variance）。自助聚合算法可以降低对数据噪声的敏感性，从而提高模型准确性和稳定性。这种方法不需要额外的输入，只是简单地对同一个数据集训练出多个模型即可实现。当然这并不是说没有代价，自助聚合算法一般会增加模型训练的计算量。</p><p>在<code>scikit-learn</code>里，由<code>BaggingClassifier</code>类和B<code>aggingRegressor</code>类分别实现了分类和回归的Bagging算法。</p><h3 id="5-2-正向激励算法Boosting"><a href="#5-2-正向激励算法Boosting" class="headerlink" title="5.2 正向激励算法Boosting"></a>5.2 正向激励算法Boosting</h3><p>正向激励算法（Boosting）的基本原理是，初始化时，针对有m个训练样本的数据集，给每个样本都分配一个初始权重，然后使用这个带有权重的数据集来训练模型。训练出模型之后，针对这个模型预测错误的那些样本，增加其权重，然后拿这个更新过权重的数据集来训练出一个新的模型。重复这个过程B次，就可以训练出B个模型。</p><p>Boosting算法和Bagging算法的区别如下：</p><ul><li>采样规则不同：Bagging算法是采样有放回的随机采样规则。而Boosting算法是使用增加预测错误样本权重的方法，相当于加强了对预测错误的样本的学习力度，从而提高模型的准确性。</li><li>训练方式不同：Bagging算法可以并行训练多个模型。而Boosting算法只能串行训练，因为下一个模型依赖上一个模型的预测结果。</li><li>模型权重不同：Bagging算法训练出来的B个模型的权重是一样的。而Boosting算法训练出来的B个模型本身带有权重信息，在对新样本进行预测时，每个模型的权重是不一样的。单个模型的权重由模型训练的效果来决定，即准确性高的模型权重更高。</li></ul><p>Boosting算法有很多种实现，其中最著名的是 <code>AdaBoosting</code> 算法。在 <code>scikit-learn</code> 里由<code>AdaBoostingClassifier</code>类和 <code>AdaBoostingRegression</code>类分别实现Boosting分类和Boosting回归。</p><h3 id="5-3-随机森林"><a href="#5-3-随机森林" class="headerlink" title="5.3 随机森林"></a>5.3 随机森林</h3><p>随机森林（RF，Random Forest）在自助聚合算法（Bagging）的基础上更进一步，对特征应用自助聚合算法。即，每次训练时，不拿所有的特征来训练，而是随机选择一个特征的子集来进行训练。随机森林算法有两个关键参数，一是构建的决策树的个数t，二是构建单棵决策树特征的个数f。</p><p>假设，针对一个有m个样本、n个特征的数据集，则其算法原理如下：</p><h4 id="单棵决策树的构建"><a href="#单棵决策树的构建" class="headerlink" title="单棵决策树的构建"></a>单棵决策树的构建</h4><ul><li>采用有放回采样，从原数据集中经过m次采样，获取到一个m个样本的数据集（这个数据集里可能有重复的样本）</li><li>从n个特征里，采用无放回采样规则，从中取出f个特征作为输入特征。</li><li>重复上述过程t次，构建出t棵决策树。</li></ul><h4 id="随机森林的分类结果"><a href="#随机森林的分类结果" class="headerlink" title="随机森林的分类结果"></a>随机森林的分类结果</h4><p> 生成t棵决策树之后，对于每个新的测试样例，集合多棵决策树的预测结果来作为随机森林的预测结果。具体为，如果是回归问题，取t棵决策树的预测值的平均值作为随机森林的预测结果；如果是分类问题，采取少数服从多数的原则，取单棵决策树预测最多的那个类别作为随机森林的分类结果。</p><blockquote><p>思考：为什么随机森林要选取特征的子集来构建决策树？</p></blockquote><p> 假如某个输入特征对预测结果是强关联的，那么如果选择全部的特征来构建决策树，这个特征都会体现在所有的决策树里面。由于这个特征和预测结果强关联，会造成所有的决策树都强烈地反映这个特征的“倾向性”，从而导致无法很好地解决过拟合问题。我们在讨论线性回归算法时，通过增加正则项来解决过拟合，它的原理就是确保每个特征都对预测结果有少量的贡献，从而避免单个特征对预测结果有过大贡献导致的过拟合问题。这里的原理是一样的。</p><p>在 <code>scikit-learn</code> 里由 <code>RandomForestClassifier</code> 类和 <code>RandomForestRegression</code> 类分别实现随机森林的分类算法和随机森林的回归算法。</p><h3 id="5-4-ExtraTrees算法"><a href="#5-4-ExtraTrees算法" class="headerlink" title="5.4 ExtraTrees算法"></a>5.4 ExtraTrees算法</h3><p>ExtraTrees，叫做极限树或者极端随机树。随机森林在构建决策树的过程中，会使用信息熵或者基尼不纯度，然后选择信息增益最大的特征来进行分裂。而 <code>ExtraTrees</code> 是直接从所有特征里随机选择一个特征来分裂，从而避免了过拟合问题。</p><p>在<code>scikit-learn</code>里，由<code>ExtraTreesClassifier</code>类和 <code>ExtraTreesRegression</code> 类分别实现 <code>ExtraTrees</code> 的分类算法和 ExtraTrees 的回归算法。</p><hr><h2 id="6-扩展阅读"><a href="#6-扩展阅读" class="headerlink" title="6. 扩展阅读"></a>6. 扩展阅读</h2><h3 id="6-1-熵和条件熵"><a href="#6-1-熵和条件熵" class="headerlink" title="6.1 熵和条件熵"></a>6.1 熵和条件熵</h3><p>在决策树创建过程中，我们会计算以某个特征创建分支后的子数据集的信息熵。用数学语言描述实际上是计算条件熵，即满足某个条件的信息熵。</p><p>关于信息熵和条件熵的相关概念，可以阅读吴军老师的<a href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E/1580521?fr=aladdin" target="_blank" rel="noopener">《数学之美》</a>里”信息的度量和作用”一文。《数学之美》这本书，吴军老师用平实的语言，把复杂的数学概念解释的入木三分，即使你只有高中的数学水平，也可以领略到数学的“优雅”和“威力”。</p><h3 id="6-2-决策树的构建算法"><a href="#6-2-决策树的构建算法" class="headerlink" title="6.2 决策树的构建算法"></a>6.2 决策树的构建算法</h3><p>本文重点介绍的决策树构建算法是ID3算法，它是1986年由Ross Quinlan提出的。1993年，该算法作者发布了新的决策树构建算法C4.5，作为ID3算法的改进，主要体现在：</p><ul><li>增加了对连续值的处理，方法是使用一个阈值作为连续值的划分条件，从而把数据离散化。</li><li>自动处理特征值缺失问题，处理方法是直接把这个特征抛弃，不参与计算信息增益比。</li><li>使用信息增益比作为特征选择标准。</li><li>采用后剪枝算法处理过拟合，即在决策树创建完成之后，再通过合并叶子节点的方式进行剪枝。</li></ul><p>此后，该算法作者又发布了改进的商业版本C5.0，它运算效率更高，使用内存更小，创建出来的决策树更小，并且准确性更高，适合大数据集的决策树构建。</p><p>除了前面介绍的使用基尼不纯度来构建决策树的CART算法之外，还有其他知名的决策树构建算法，如CHAID算法、MARS算法等。这里不再详述。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> ML算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scikit-learn系列四：逻辑回归</title>
      <link href="/2020/06/30/scikit-learn-xi-lie-si-luo-ji-hui-gui/"/>
      <url>/2020/06/30/scikit-learn-xi-lie-si-luo-ji-hui-gui/</url>
      
        <content type="html"><![CDATA[<h2 id="项目地址传送门，欢迎-star-和-fork-！"><a href="#项目地址传送门，欢迎-star-和-fork-！" class="headerlink" title="项目地址传送门，欢迎 star 和 fork ！"></a>项目地址<a href="https://github.com/DongZhouGu/scikit-learn-ml" target="_blank" rel="noopener">传送门</a>，欢迎 star 和 fork ！</h2><h2 id="1-Logistic-回归概述"><a href="#1-Logistic-回归概述" class="headerlink" title="1. Logistic 回归概述"></a>1. Logistic 回归概述</h2><p>Logistic 回归 或者叫逻辑回归，虽然名字有回归，但是它是用来做分类的。其主要思想是: 根据现有数据对分类边界线 (Decision Boundary) 建立回归公式，以此进行分类。</p><h2 id="2-算法原理"><a href="#2-算法原理" class="headerlink" title="2. 算法原理"></a>2. 算法原理</h2><p>假设有一场足球赛，我们有两支球队的所有出场球员信息、历史交锋成绩、比赛时间、主客场、裁判和天气等信息，根据这些信息预测球队的输赢。假设比赛结果记为y，赢球标记为1，输球标记为0，这就是典型的二元分类问题，可以用逻辑回归算法来解决。</p><p>与线性回归算法的最大区别是，逻辑回归算法的输出是个离散值。</p><h3 id="2-1-预测函数"><a href="#2-1-预测函数" class="headerlink" title="2.1 预测函数"></a>2.1 预测函数</h3><p>需要找出一个预测函数模型，使其值输出在[0,1]之间。然后选择一个基准值，如0.5，如果算出来的预测值大于0.5，就认为其预测值为1，反之，则其预测值为0。</p><p>选择Sigmoid函数（也称为Logistic函数，逻辑回归的名字由此而来）<br>$$<br>g(z)=\frac{1}{1+e^{-z}}<br>$$<br>来作为预测函数，其中e是自然对数的底数。以z为横坐标，以g(z)为纵坐标，画出的图形如下所示：</p><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/LR_3.png" alt="Sigmoid 函数在不同坐标下的图片"></p><p>从图中可以看出，当z=0时，g(z)=0.5；当z&gt;0时，g(z)&gt;0.5，当z越来越大时，g(z)无限接近于1；当z&lt;0时，g(z)&lt;0.5，当z越来越小时，g(z)无限接近于0。这正是我们想要的针对二元分类算法的预测函数。</p><h3 id="2-2-判定边界"><a href="#2-2-判定边界" class="headerlink" title="2.2 判定边界"></a>2.2 判定边界</h3><p>逻辑回归算法的预测函数由下面两个公式给出：<br>$$<br>h_{\theta}(x)=g\left(\theta^{T} x\right)<br>$$</p><p>$$<br>g(z)=\frac{1}{1+e^{-z}}<br>$$</p><p>下面给出两个判定边界的例子。假设有两个变量x1，x2，其逻辑回归预测函数是$h_{\theta}(x)=g\left(\theta_{0}+\theta_{1} x_{1}+\theta_{2} x_{2}\right)$</p><p>假设给定参数：<br>$$<br>\theta=\left[\begin{array}{c}<br>-3 \<br>1 \<br>1<br>\end{array}\right]<br>$$<br>那么，可以得到判定边$-3+x_{1}+x_{2}=0$ ，如果以 $x_{1}$ 为横坐标， $x_{2}$  为纵坐标，则这个函数画出来就是一条通过(0,3)和(3,0)两点的直线。这条线就是判定边界，其中，直线左下方为y=0，直线右上方为y=1，如图所示：</p><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/17634123-0bf913a36c2847a8.png" alt="img"></p><p>如果预测函数是多项式 $h_{\theta}(x)=g\left(\theta_{0}+\theta_{1} x_{1}+\theta_{2} x_{2}+\theta_{3} x_{1}^{2}+\theta_{4} x_{2}^{2}\right)$，且给定</p><p>$$<br>\theta=\left[\begin{array}{c}<br>-1 \<br>0 \<br>0 \<br>1 \<br>1<br>\end{array}\right]<br>$$<br>则可以得到判定边界函数$x_{1}^{2}+x_{2}^{2}=1$ 则这是一个半径为1的圆。圆内部是y=0，圆外部是y=1，如上图所示。</p><h3 id="2-3-损失函数"><a href="#2-3-损失函数" class="headerlink" title="2.3 损失函数"></a>2.3 损失函数</h3><p>我们不能使用线性回归模型的损失函数来推导逻辑回归的损失函数，因为那样的损失函数太复杂，最终很可能会导致无法通过迭代找到损失函数值最小的点。</p><p>为了容易地求出损失函数的最小值，我们分成 y=1 和 y=0 两种情况来分别考虑其预测值和真实值的误差。我们先考虑最简单的情况，即计算某个样本 x，y=1 和 y=0 两种情况下的预测值与真实值的误差，我们选择的损失公式如下：</p><p>$\operatorname{cost}\left(h_{\theta}(x), y\right)=\left{\begin{array}{ccc}-\log \left(h_{\theta}(x)\right), &amp; \text { if } &amp; y=1 \ -\log \left(1-h_{\theta}(x)\right), &amp; \text { if } &amp; y=0\end{array}\right.$</p><p>其中， $h_{\theta}(x)$ 表示预测为1的概率，log(x)为自然对数。如图所示</p><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200630141514106.png" alt="img"></p><p>根据损失函数的定义，损失是预测值与真实值的差异。当差异越大时，损失越大，模型受到的“惩罚”也越严重。在左图中，当 y=1 时，随着（预测为1的概率）越来越大，预测值越来越接近真实值，其损失越来越小；在右图中，当 y=0 时，随着（预测为1的概率）越来越大，预测值越来越偏离真实值，其损失越来越大。</p><h3 id="2-4-梯度下降算法"><a href="#2-4-梯度下降算法" class="headerlink" title="2.4 梯度下降算法"></a>2.4 梯度下降算法</h3><p>和线性回归类似，这里使用梯度下降算法来求解逻辑回归模型参数。具体可见上一节 <a href="https://dongzhougu.github.io/2020/06/30/scikit-learn-xi-lie-san-xian-xing-hui-gui/">线性回归回归算法</a>。</p><h2 id="3-多元分类"><a href="#3-多元分类" class="headerlink" title="3. 多元分类"></a>3. 多元分类</h2><p>逻辑回归模型可以解决二元分类问题，即 y={0,1}，能不能解决多元分类问题呢？答案是肯定的。针对多元分类问题，y={0,1,2,3,…,n}，总共有n+1个类别。其解决思路是：首先把问题转换为二元分类问题，即y=0是一个类别，y={1,2,3,…,n}作为另外一个类别，然后计算这两个类别的概率；接着，把y=1作为一个类别，把y={0,2,3,…,n}作为另外一个类别，再计算这两个类别的概率。</p><h2 id="4-正则化"><a href="#4-正则化" class="headerlink" title="4. 正则化"></a>4. 正则化</h2><p>我们知道，过拟合是指模型很好地拟合了训练样本，但对新数据预测的准确性很差，这是因为模型太复杂了。解决办法是减少输入特征的个数，或者获取更多的训练样本。这里介绍的正则化也可以用来解决过拟合问题：</p><ul><li><p>保留所有的特征，减少特征的权重 $\theta_{j} $ 的值。确保所有的特征对预测值都有少量的贡献。</p></li><li><p>当每个特征 $x_{j} $ 对预测值y都有少量的贡献时，这样的模型可以良好的工作，这正是正则化的目的，可以用它来解决特征过多时的过拟合问题。</p></li></ul><h3 id="4-1-线性回归模型正则化"><a href="#4-1-线性回归模型正则化" class="headerlink" title="4.1 线性回归模型正则化"></a>4.1 线性回归模型正则化</h3><p>我们先来看线性回归模型的损失函数是如何正则化的：<br>$$<br>J(\theta)=\frac{1}{2 m} \sum_{i=1}^{m}\left(h_{\theta}\left(x^{(i)}\right)-y^{(i)}\right)^{2}+\lambda \sum_{j=1}^{n} \theta_{j}^{2}<br>$$<br>公式中前半部分就是原来的线性回归模型的损失函数，也称为预测值与实际值的误差。后半部分为加入的正则项。其中 $\lambda $ 的值有两个目的，即要维持对训练样本的拟合，又要避免对训练样本的过拟合。如果  $\lambda $  的值太大，则能确保不出现过拟合，但可能会导致对现有训练样本出现欠拟合。</p><h3 id="4-2-线性回归模型正则化"><a href="#4-2-线性回归模型正则化" class="headerlink" title="4.2 线性回归模型正则化"></a>4.2 线性回归模型正则化</h3><p>同样，可以对逻辑回归模型的损失函数进行正则化，其方法也是在原来的损失函数的基础上加上正则项：<br>$$<br>J(\theta)=-\frac{1}{m}\left[\sum_{i=1}^{m} y^{(i)} \log \left(h_{\theta}\left(x^{(i)}\right)\right)+\left(1-y^{(i)}\right) \log \left(1-h_{\theta}\left(x^{(i)}\right)\right)\right]+\frac{\lambda}{2 m} \sum_{j=1}^{n} \theta_{j}^{2}<br>$$</p><h2 id="5-算法参数"><a href="#5-算法参数" class="headerlink" title="5. 算法参数"></a>5. 算法参数</h2><p>在 <code>scikit-learn</code>里，逻辑回归模型由类 <code>sklearn.linear_model.LogisticRegression</code>实现。</p><h3 id="5-1-正则项权重"><a href="#5-1-正则项权重" class="headerlink" title="5.1 正则项权重"></a>5.1 正则项权重</h3><p>上面介绍的正则项权重  $\lambda $  ，在<code>LogisticRegression</code>类里有个参数 C 与之对应，但成反比。即 C 值越大，  $\lambda $ 越小，模型容易出现过拟合；C 值越小，  $\lambda $  越大，模型容易出现欠拟合。</p><h3 id="5-2-L1-L2范数"><a href="#5-2-L1-L2范数" class="headerlink" title="5.2 L1/L2范数"></a>5.2 L1/L2范数</h3><p>创建逻辑回归模型时，有个参数penalty（惩罚），其取值有“l1”或“l2”</p><ul><li>L1范数作为正则项，会让模型参数 $\theta$ 稀疏化，即让模型参数向量里的0元素尽可能多，只保留模型参数向量中重要特征的贡献。</li><li>L2范数作为正则项，则让模型参数尽量小，但不会为0，即尽量让每个特征对应预测值都有一些小的贡献。</li></ul><p>假设模型只有两个参数，它们构成一个二维向量 $\theta=\left[\theta_{1}, \theta_{2}\right]$,则L1范数为：</p><p>$|\theta|<em>{1}=\left|\theta</em>{1}\right|+\left|\theta_{2}\right|$</p><p>即L1范数是向量里元素的绝对值之和。L2范数为向量里所有元素的平方和的算术平方根：</p><p>$|\theta|<em>{2}=\sqrt{\theta</em>{1}^{2}+\theta_{2}^{2}}$</p><p>我们知道，梯度下降算法在参数迭代的过程中，实际上是在损失函数的等高线上跳跃，并最终收敛在误差最小的点上。那么正则项的本质是什么？正则项的本质是惩罚。在参数迭代的过程中，如果没有遵循正则项所表达的规则，那么其损失会变大，即受到了惩罚，从而往正则项所表达的规则处收敛。正则化后的模型参数应该收敛在误差等高线与正则项等高线相切的点上。</p><p>作为推论，L1范数作为正则项，有以下几个用途：</p><ul><li>选择重要特征：L1范数会让模型参数向量里的元素为0的点尽量多，这样可以排除掉那些对预测值没有什么影响的特征，从而简化问题。所以L1范数解决过拟合，实际上是减少特征数量。</li><li>模型可解释性好：模型参数向量稀疏化后，只会留下那些对预测值有重要影响的特征。这样我们就容易解释模型的因果关系。比如，针对某种癌症的筛查，如果有100个特征，那么我们无从解释到底哪些特征对阳性呈关键作用。稀疏化后，只留下几个关键的特征，就容易看到因果关系。</li></ul><p>由此可见，L1范数作为正则项，更多的是一个分析工具，而适合用来对模型求解。因为它会把不重要的特征直接去除。大部分的情况下解决过拟合问题，还是选择L2范数作为正则项，这也是 <code>scikit-learn</code> 里的默认值。</p><h2 id="6-示例：乳腺癌检测"><a href="#6-示例：乳腺癌检测" class="headerlink" title="6 示例：乳腺癌检测"></a>6 示例：乳腺癌检测</h2><p>本节来看一个实例，使用逻辑回归算法解决乳腺癌检测问题。我们需要先采集肿瘤病灶造影图片，然后对图片进行分析，从图片中提取特征，再根据特征来训练模型。最终使用模型来检测新采集到的肿瘤病灶造影，以便判断肿瘤是良性的还是恶性的。这是个典型的二元分类问题。</p><h3 id="6-1-数据采集及特征提取"><a href="#6-1-数据采集及特征提取" class="headerlink" title="6.1 数据采集及特征提取"></a>6.1 数据采集及特征提取</h3><p>为了简单起见，直接加载 <code>scikit-learn</code> 自带的一个乳腺癌数据集。这个数据集是已经采集后的数据：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>datasets <span class="token keyword">import</span> load_breast_cancercancer <span class="token operator">=</span> load_breast_cancer<span class="token punctuation">(</span><span class="token punctuation">)</span>X <span class="token operator">=</span> cancer<span class="token punctuation">.</span>datay <span class="token operator">=</span> cancer<span class="token punctuation">.</span>target<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'data shape: {0}; no. positive: {1}; no. negative: {2}'</span>      <span class="token punctuation">.</span>format<span class="token punctuation">(</span>X<span class="token punctuation">.</span>shape<span class="token punctuation">,</span>y<span class="token punctuation">[</span>y<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>y<span class="token punctuation">[</span>y<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>cancer<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出如下：</p><pre class="line-numbers language-python"><code class="language-python">data shape<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token number">569</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span> no<span class="token punctuation">.</span> positive<span class="token punctuation">:</span> <span class="token number">357</span><span class="token punctuation">;</span> no<span class="token punctuation">.</span> negative<span class="token punctuation">:</span> <span class="token number">212</span><span class="token punctuation">[</span><span class="token number">1.799e+01</span> <span class="token number">1.038e+01</span> <span class="token number">1.228e+02</span> <span class="token number">1.001e+03</span> <span class="token number">1.184e-01</span> <span class="token number">2.776e-01</span> <span class="token number">3.001e-01</span> <span class="token number">1.471e-01</span> <span class="token number">2.419e-01</span> <span class="token number">7.871e-02</span> <span class="token number">1.095e+00</span> <span class="token number">9.053e-01</span> <span class="token number">8.589e+00</span> <span class="token number">1.534e+02</span> <span class="token number">6.399e-03</span> <span class="token number">4.904e-02</span> <span class="token number">5.373e-02</span> <span class="token number">1.587e-02</span> <span class="token number">3.003e-02</span> <span class="token number">6.193e-03</span> <span class="token number">2.538e+01</span> <span class="token number">1.733e+01</span> <span class="token number">1.846e+02</span> <span class="token number">2.019e+03</span> <span class="token number">1.622e-01</span> <span class="token number">6.656e-01</span> <span class="token number">7.119e-01</span> <span class="token number">2.654e-01</span> <span class="token number">4.601e-01</span> <span class="token number">1.189e-01</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数据集中总共有569个样本，每个样本有30个特征，其中357个阳性（y=1）样本，212个阴性（y=0）样本。同时，还打印出一个样本数据，以便直观地进行观察。</p><p>这30个特征是怎么来的呢？这个数据集总共从病灶造影图片中提取了以下10个关键属性：</p><ul><li>radius：半径，即病灶中心点离边界的平均距离。</li><li>texture：纹理，灰度值的标准偏差。</li><li>perimeter：周长，即病灶的大小。</li><li>area：面积，也是反映病灶大小的一个指标。</li><li>smoothness：平滑度，即半径的变化幅度。</li><li>compactness：密实度，周长的平方除以面积，再减去1</li><li>concavity：凹度，凹陷部分轮廓的严重程度。</li><li>concave points：凹点，凹陷轮廓的数量。</li><li>symmetry：对称性。</li><li>fractal demension：分形维度。</li></ul><p>实际上它只关注10个特征，然后又构造出了每个特征的标准差及最大值，这样每个特征就衍生出了两个特征，所以总共就有了30个特征。可以通过 <code>cancer.feature_names</code> 变量来查看这些特征的名称。</p><h3 id="6-2-模型训练"><a href="#6-2-模型训练" class="headerlink" title="6.2 模型训练"></a>6.2 模型训练</h3><p>首先，把数据集分成训练数据集和测试数据集：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> train_test_splitX_train<span class="token punctuation">,</span>X_test<span class="token punctuation">,</span>y_train<span class="token punctuation">,</span>y_test <span class="token operator">=</span> train_test_split<span class="token punctuation">(</span>X<span class="token punctuation">,</span>y<span class="token punctuation">,</span>test_size<span class="token operator">=</span><span class="token number">0.2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后使用 <code>LogisticRegression</code> 模型来训练，并计算训练数据集的评分数据和测试数据集的评分数据：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>linear_model <span class="token keyword">import</span> LogisticRegressionmodel <span class="token operator">=</span> LogisticRegression<span class="token punctuation">(</span><span class="token punctuation">)</span>model<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span>y_train<span class="token punctuation">)</span>train_score <span class="token operator">=</span> model<span class="token punctuation">.</span>score<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span>y_train<span class="token punctuation">)</span>test_score <span class="token operator">=</span> model<span class="token punctuation">.</span>score<span class="token punctuation">(</span>X_test<span class="token punctuation">,</span>y_test<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'train score: {train_score:.6f}; test_score:{test_score:.6f}'</span>      <span class="token punctuation">.</span>format<span class="token punctuation">(</span>train_score<span class="token operator">=</span>train_score<span class="token punctuation">,</span>             test_score<span class="token operator">=</span>test_score<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出如下：</p><pre class="line-numbers language-css"><code class="language-css">train <span class="token property">score</span><span class="token punctuation">:</span> <span class="token number">0.940659</span><span class="token punctuation">;</span> <span class="token property">test_score</span><span class="token punctuation">:</span><span class="token number">0.964912</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>观察模型在测试样本集的表现：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> npy_pred <span class="token operator">=</span> model<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>X_test<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'matchs: {0}/{1}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>np<span class="token punctuation">.</span>equal<span class="token punctuation">(</span>y_pred<span class="token punctuation">,</span>y_test<span class="token punctuation">)</span><span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>y_test<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>输出如下：</p><pre class="line-numbers language-python"><code class="language-python">matchs<span class="token punctuation">:</span> <span class="token number">114</span><span class="token operator">/</span><span class="token number">114</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>总共114个测试样本，全部预测正确。为什么 <code>testscore</code> 却只有0.973684，而不是1呢？答案是，<code>scikit-learn</code>不是使用这个数据来计算分数，因为这个数据不能完全反映误差情况，而是使用预测概率数据计算模型评分。</p><p>针对二元分类问题，<code>LogisticRegression</code>模型会对每个样本输出两个概率，即为 0 的概率和为 1 的概率，哪个概率高就预测为哪个类别。</p><p>找出测试数据集中预测“自信度”低于90%的样本。这里先计算出测试数据集里的每个样本的预测概率数据，针对每个样本，它会有两个数据，一是预测其为阳性的概率，另外一个是预测其为阴性的概率。接着找出预测为阴性的概率大于0.1且小于0.9的样本（同时也是预测为阳性的概率大于0.1小于0.9），这些样本就是“自信度”不足90%的样本。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 预测概率：找出预测概率低于 90% 的样本</span>y_pred_proba <span class="token operator">=</span> model<span class="token punctuation">.</span>predict_proba<span class="token punctuation">(</span>X_test<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 计算每个测试样本的预测概率</span><span class="token comment" spellcheck="true"># 找出第一列，即预测为阴性的概率大于 0.1 的样本，保存在 result 里</span>y_pred_proba_0 <span class="token operator">=</span> y_pred_proba<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0.1</span>result <span class="token operator">=</span> y_pred_proba<span class="token punctuation">[</span>y_pred_proba_0<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 在 result 结果集里，找出第二列，即预测为阳性的概率大于 0.1 的样本</span>y_pred_proba_1 <span class="token operator">=</span> result<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0.1</span><span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">[</span>y_pred_proba_1<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0.29623162</span> <span class="token number">0.70376838</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">0.54660262</span> <span class="token number">0.45339738</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">0.17874247</span> <span class="token number">0.82125753</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">0.20917573</span> <span class="token number">0.79082427</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">0.10943452</span> <span class="token number">0.89056548</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">0.35503614</span> <span class="token number">0.64496386</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">0.23849987</span> <span class="token number">0.76150013</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">0.13634228</span> <span class="token number">0.86365772</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">0.80171734</span> <span class="token number">0.19828266</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">0.21744759</span> <span class="token number">0.78255241</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">0.81346356</span> <span class="token number">0.18653644</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">0.2225791</span>  <span class="token number">0.7774209</span> <span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">0.10788007</span> <span class="token number">0.89211993</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">0.88068005</span> <span class="token number">0.11931995</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">0.18189724</span> <span class="token number">0.81810276</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由此可见，计算预测概率使用model.predict_proba()函数，而计算预测分类用model.predict()函数。</p><h3 id="6-3-模型优化"><a href="#6-3-模型优化" class="headerlink" title="6.3 模型优化"></a>6.3 模型优化</h3><p>首先，使用Pipeline来增加多项式特征：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>linear_model <span class="token keyword">import</span> LogisticRegression<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>preprocessing <span class="token keyword">import</span> PolynomialFeatures<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>pipeline <span class="token keyword">import</span> Pipeline<span class="token comment" spellcheck="true"># 增加多项式预处理</span><span class="token keyword">def</span> <span class="token function">polynomial_model</span><span class="token punctuation">(</span>degree<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">**</span>kwarg<span class="token punctuation">)</span><span class="token punctuation">:</span>    polynomial_features <span class="token operator">=</span> PolynomialFeatures<span class="token punctuation">(</span>degree<span class="token operator">=</span>degree<span class="token punctuation">,</span>                                             include_bias<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>    logistic_regression <span class="token operator">=</span> LogisticRegression<span class="token punctuation">(</span><span class="token operator">**</span>kwarg<span class="token punctuation">)</span>    pipeline <span class="token operator">=</span> Pipeline<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">"polynomial_features"</span><span class="token punctuation">,</span> polynomial_features<span class="token punctuation">)</span><span class="token punctuation">,</span>                         <span class="token punctuation">(</span><span class="token string">"logistic_regression"</span><span class="token punctuation">,</span> logistic_regression<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> pipeline<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着，增加二阶多项式特征，创建并训练模型：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> timemodel <span class="token operator">=</span> polynomial_model<span class="token punctuation">(</span>degree<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> penalty<span class="token operator">=</span><span class="token string">'l1'</span><span class="token punctuation">,</span> solver<span class="token operator">=</span><span class="token string">'liblinear'</span><span class="token punctuation">)</span>start <span class="token operator">=</span> time<span class="token punctuation">.</span>process_time<span class="token punctuation">(</span><span class="token punctuation">)</span>model<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span> y_train<span class="token punctuation">)</span>train_score <span class="token operator">=</span> model<span class="token punctuation">.</span>score<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span> y_train<span class="token punctuation">)</span>test_score <span class="token operator">=</span> model<span class="token punctuation">.</span>score<span class="token punctuation">(</span>X_test<span class="token punctuation">,</span> y_test<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'elaspe: {0:.6f}; train_score: {1:0.6f}; cv_score: {2:.6f}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>    time<span class="token punctuation">.</span>process_time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">,</span> train_score<span class="token punctuation">,</span> test_score<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用L1范数作为正则项（参数penalty=’l1’），输出如下：</p><pre class="line-numbers language-python"><code class="language-python">elaspe<span class="token punctuation">:</span> <span class="token number">0.156250</span><span class="token punctuation">;</span> train_score<span class="token punctuation">:</span> <span class="token number">1.000000</span><span class="token punctuation">;</span> cv_score<span class="token punctuation">:</span> <span class="token number">0.956140</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到，训练数据集评分和测试数据集评分都增加了。为什么使用L1范数作为正则项呢？L1范数作为正则项可以实现参数的稀疏化，即自动选择出那些对模型有关联的重要特征。</p><pre class="line-numbers language-python"><code class="language-python">logistic_regression <span class="token operator">=</span> model<span class="token punctuation">.</span>named_steps<span class="token punctuation">[</span><span class="token string">'logistic_regression'</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'model parameters shape: {0}; count of non-zero element: {1}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>    logistic_regression<span class="token punctuation">.</span>coef_<span class="token punctuation">.</span>shape<span class="token punctuation">,</span>     np<span class="token punctuation">.</span>count_nonzero<span class="token punctuation">(</span>logistic_regression<span class="token punctuation">.</span>coef_<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>输出如下：</p><pre class="line-numbers language-python"><code class="language-python">model parameters shape<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">495</span><span class="token punctuation">)</span><span class="token punctuation">;</span> count of non<span class="token operator">-</span>zero element<span class="token punctuation">:</span> <span class="token number">110</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>逻辑回归模型的coef_属性里保存的就是模型参数。从输出结果可以看到，增加二阶多项式特征后，输入特征由原来的30个增加到了495个，最终大多数特征都被丢弃，只保留了110个有效特征。</p><h3 id="6-4-学习曲线"><a href="#6-4-学习曲线" class="headerlink" title="6.4 学习曲线"></a>6.4 学习曲线</h3><p>首先画出使用L1范数作为正则项所对应的一阶和二阶多项式的学习曲线：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> utils <span class="token keyword">import</span> plot_learning_curve<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> ShuffleSplit<span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> pyplot <span class="token keyword">as</span> pltcv <span class="token operator">=</span> ShuffleSplit<span class="token punctuation">(</span>n_splits<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span> test_size<span class="token operator">=</span><span class="token number">0.2</span><span class="token punctuation">,</span> random_state<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>title <span class="token operator">=</span> <span class="token string">'Learning Curves (degree={0}, penalty={1})'</span>degrees <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span>penalty <span class="token operator">=</span> <span class="token string">'l1'</span>start <span class="token operator">=</span> time<span class="token punctuation">.</span>process_time<span class="token punctuation">(</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dpi<span class="token operator">=</span><span class="token number">144</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>degrees<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>degrees<span class="token punctuation">)</span><span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>    plot_learning_curve<span class="token punctuation">(</span>plt<span class="token punctuation">,</span> polynomial_model<span class="token punctuation">(</span>degree<span class="token operator">=</span>degrees<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> penalty<span class="token operator">=</span>penalty<span class="token punctuation">,</span> solver<span class="token operator">=</span><span class="token string">'liblinear'</span><span class="token punctuation">,</span> max_iter<span class="token operator">=</span><span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                         title<span class="token punctuation">.</span>format<span class="token punctuation">(</span>degrees<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> penalty<span class="token punctuation">)</span><span class="token punctuation">,</span> X<span class="token punctuation">,</span> y<span class="token punctuation">,</span> ylim<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0.8</span><span class="token punctuation">,</span> <span class="token number">1.01</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cv<span class="token operator">=</span>cv<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'elaspe: {0:.6f}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>time<span class="token punctuation">.</span>process_time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出的结果如下：</p><pre class="line-numbers language-python"><code class="language-python">l1_elaspe<span class="token punctuation">:</span> <span class="token number">10.781250</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>L1范数学习曲线如下图所示：</p><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/17634123-08d8944e88c2ae64.png" alt="image-20200630141514106"></p><p>接着画出使用L2范数作为正则项所对应的一阶和二阶多项式的学习曲线：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> warningswarnings<span class="token punctuation">.</span>filterwarnings<span class="token punctuation">(</span><span class="token string">"ignore"</span><span class="token punctuation">)</span>penalty <span class="token operator">=</span> <span class="token string">'l2'</span>start <span class="token operator">=</span> time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dpi<span class="token operator">=</span><span class="token number">144</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>degrees<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>degrees<span class="token punctuation">)</span><span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>    plot_learning_curve<span class="token punctuation">(</span>plt<span class="token punctuation">,</span> polynomial_model<span class="token punctuation">(</span>degree<span class="token operator">=</span>degrees<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> penalty<span class="token operator">=</span>penalty<span class="token punctuation">,</span> solver<span class="token operator">=</span><span class="token string">'lbfgs'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                         title<span class="token punctuation">.</span>format<span class="token punctuation">(</span>degrees<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> penalty<span class="token punctuation">)</span><span class="token punctuation">,</span> X<span class="token punctuation">,</span> y<span class="token punctuation">,</span> ylim<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0.8</span><span class="token punctuation">,</span> <span class="token number">1.01</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cv<span class="token operator">=</span>cv<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'elaspe: {0:.6f}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出的结果如下：</p><pre class="line-numbers language-python"><code class="language-python">l2_elaspe<span class="token punctuation">:</span> <span class="token number">2.718750</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>L2范数学习曲线如下图所示：</p><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200630141743010.png" alt="image-20200630141743010"></p><p>可以明显地看出，使用二阶多项式并使用L1范数作为正则项的模型最优，因为它的训练样本评分最高，交叉验证样本评分也最高。从图中还可以看出，训练样本评分和交叉验证样本评分之间的间隙还比较大，我们可以采集更多的数据来训练模型，以便进一步优化模型。</p><p>另外从输出的时间可以看出，L1 范数对应的学习曲线，需要花费较长的时间，原因是，<code>scikit-learn</code> 的<code>learning_curve()</code> 函数在画学习曲线的过程中，要对模型进行多次训练，并计算交叉验证样本评分。同时，为了使曲线更平滑，针对每个点还会进行多次计算求平均值。这个就是 <code>ShuffleSplit</code> 类的作用。在我们这个实例里，只有569个训练样本，这是个很小的数据集。如果数据集增加100倍，甚至1000倍，拿出来画学习曲线将是场灾难。</p><p>那么，针对大数据集，怎样高效地画学习曲线？答案很简单，可以从大数据集里选择一小部分数据来画学习曲线，待选择好最优的模型之后，再使用全部的数据集来训练模型。但是要尽量保持选择出来的这部分数据的标签分布与大数据集的标签分布相同，如针对二元分类，阳性和阴性比例要一致。更直观的说就是，抽取出来的样本集为原来数据集的一个缩影，尽可能相似。</p><h2 id="7-拓展阅读"><a href="#7-拓展阅读" class="headerlink" title="7.拓展阅读"></a>7.拓展阅读</h2><p>实际上，我们的预测函数就是写成向量形式的：<br>$$<br>h_{\theta}(x)=g(z)=g\left(\theta^{T} x\right)=\frac{1}{1+e^{-\theta^{T} x}}<br>$$<br>这个预测函数一次只计算一个训练样本的预测值，怎样一次性计算出所有样本的预测值呢？答案是把预测函数的参数写成向量的形式：<br>$$<br>h=g(X \theta)<br>$$<br>其中g(x)为Sigmoid函数。X为m×n的矩阵，即数据集的矩阵表达。损失函数也有对应的矩阵形式：<br>$$<br>J(\theta)=\frac{1}{m}\left(-y^{T} \log (h)-(1-y)^{T} \log (1-h)\right)<br>$$<br>其中，y为目标值向量，h为一次性计算出来的所有样本的预测值。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> ML算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scikit-learn系列三：线性回归</title>
      <link href="/2020/06/30/scikit-learn-xi-lie-san-xian-xing-hui-gui/"/>
      <url>/2020/06/30/scikit-learn-xi-lie-san-xian-xing-hui-gui/</url>
      
        <content type="html"><![CDATA[<h2 id="项目地址传送门，欢迎-star-和-fork-！"><a href="#项目地址传送门，欢迎-star-和-fork-！" class="headerlink" title="项目地址传送门，欢迎 star 和 fork ！"></a>项目地址<a href="https://github.com/DongZhouGu/scikit-learn-ml" target="_blank" rel="noopener">传送门</a>，欢迎 star 和 fork ！</h2><h1 id="线性回归算法"><a href="#线性回归算法" class="headerlink" title="线性回归算法"></a>线性回归算法</h1><p>线性回归算法是使用线性方程对数据集拟合的算法，本文从单变量线性回归算法、多变量线性回归算法，其中损失函数以及梯度下降算法的推导过程会用到部分线性代数和偏导数；接着重点介绍了梯度下降算法的求解步骤以及性能优化方面的内容；最后通过一个房价预测模型，介绍了线性回归算法性能优化的一些常用步骤和方法。</p><h2 id="线性回归概述"><a href="#线性回归概述" class="headerlink" title="线性回归概述"></a>线性回归概述</h2><p>说到回归，一般都是指 <code>线性回归(linear regression)</code>。线性回归意味着可以将输入项分别乘以一些常量，再将结果加起来得到输出。回归的目的是预测数值型的目标值，最直接的办法是依据输入写出一个目标值的计算公式。</p><p>假如你想要预测兰博基尼跑车的功率大小，可能会这样计算:</p><blockquote><p>HorsePower = 0.0015 * annualSalary - 0.99 * hoursListeningToPublicRadio</p></blockquote><p>这就是所谓的 <code>回归方程(regression equation)</code>，其中的 0.0015 和 -0.99 称作 <code>回归系数（regression weights）</code>，求这些回归系数的过程就是回归。一旦有了这些回归系数，再给定输入，做预测就非常容易了。具体的做法是用回归系数乘以输入值，再将结果全部加在一起，就得到了预测值。我们这里所说的，回归系数是一个向量，输入也是向量，这些运算也就是求出二者的内积。</p><h2 id="单变量线性回归算法"><a href="#单变量线性回归算法" class="headerlink" title="单变量线性回归算法"></a>单变量线性回归算法</h2><p>先考虑最简单的单变量线性回归算法，即只有一个输入特征。</p><h3 id="预测函数"><a href="#预测函数" class="headerlink" title="预测函数"></a>预测函数</h3><p>针对数据集x和y，预测函数会根据输入特征x来计算输出值h(x)。其输入和输出的函数关系如下：<br>$$<br>h_{\theta}(x)=\theta_{0}+\theta_{1} x<br>$$</p><p>这个方程表达的是一条直线。我们的任务是构造一个 $h_{\theta}$ 函数，来映射数据集中的输入特征x和输出值y，使得预测函数 $h_{\theta}$ 计算出来的值与真实值y的整体误差最小。构造  $h_{\theta}$ 函数的关键就是找到合适的 $\theta_{0}$和 $\theta_{1}$ 的值， 模型参数，也就是所说的模型参数。</p><p>假设有如下的数据集：</p><table><thead><tr><th align="center">输入特征x</th><th align="center">输出y</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">4</td></tr><tr><td align="center">2</td><td align="center">6</td></tr><tr><td align="center">3</td><td align="center">10</td></tr><tr><td align="center">4</td><td align="center">15</td></tr></tbody></table><p>假设模型参数 $\theta_{0}=1,  \theta_{1}=3$ ,  则预测函数为 $h_{\theta}(x)=1+3 x$ 。针对数据集中的第一个样本，输入为1，根据模型函数预测出来的值是4，与输出值y是吻合的。针对第二个样本，输入为2，根据模型函数预测出来的值是7，与实际输出值y相差1。模型的求解过程就是找出一组最合适的模型参数 $\theta_{0}$和 $\theta_{1}$，以便能最好地拟合数据集。</p><p>怎样来判断最好地拟合了数据集呢？没错，就是使用损失函数（也叫损失函数）。当拟合损失最小时，即找到了最好的拟合参数。</p><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>单变量线性回归算法的损失函数是：</p><p>$$<br>J(\theta)=J\left(\theta_{0}, \theta_{1}\right)=\frac{1}{2 m} \sum_{i=1}^{m}\left(h\left(x^{(i)}\right)-y^{(i)}\right)^{2}<br>$$<br>其中，$h\left(x^{(i)}\right)-y^{(i)}$ 是预测值和真实值之间的误差，故损失就是预测值和真实值之间误差平方的平均值，之所以乘以1/2是为了方便计算。这个函数也称为均方差公式。有了损失函数，就可以精确地测量模型对训练样本拟合的好坏程度。</p><h3 id="梯度下降算法"><a href="#梯度下降算法" class="headerlink" title="梯度下降算法"></a>梯度下降算法</h3><p>有了预测函数，也可以精确地测量预测函数对训练样本的拟合情况。但怎么求解模型参数 $\theta_{0}$和 $\theta_{1}$的值呢？这时梯度下降算法就排上了用场。</p><p>我们的任务是找到合适的 $\theta_{0}$和 $\theta_{1}$ ，使得损失函数 $J\left(\theta_{0}, \theta_{1}\right)$ 最小。为了便于理解，我们切换到三维空间来描述这个任务。在一个三维空间里，以  $\theta_{0}$ 作为 x 轴， 以 $\theta_{1}$ 作为 y 轴，以损失函数 $J\left(\theta_{0}, \theta_{1}\right)$ 作为 z 轴，那么我们的任务就是要找出当 z 轴上的值最小的时候所对应的 x 轴上的值和 y 轴上的值。</p><p><strong>梯度下降算法的原理：</strong>先随机选择一组 $\theta_{0}$ 和 $\theta_{1}$ ，同时选择一个参数 $\alpha$ 作为移动的步长。然后，让x轴上的 $\theta_{0}$ 和 y轴上的  $\theta_{1}$ 别向特定的方向移动一小步，这个步长的大小就由参数  $\alpha$ 决定。经过多次迭代之后，x 轴和 y 轴上的值决定的点就慢慢靠近 z 轴上的最小值处，如图所示。</p><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/u=3721595541,2272727131&amp;fm=26&amp;gp=0.jpg" alt="img"></p><p>那特定的方向怎么确定呢？答案是<strong>偏导数</strong>。</p><p>可以简单地把偏导数理解为斜率。我们要让 $\theta_{j}$ 不停地迭代，由当前  $\theta_{j}$ 的值，根据 $J(\theta)$ 的偏导数函数，算出 $J(\theta)$ 在  $\theta_{j}$ 上的斜率，然后在乘以学习率  $\alpha$ ，就可以让 $\theta_{j}$ 往 $J(\theta)$ 变小的方向迈一小步。</p><p>用数学来描述上述过程，梯度下降的公式为：<br>$$<br>\theta_{j}=\theta_{j}-\alpha \frac{\partial}{\partial \theta_{j}} J(\theta)<br>$$<br>把损失函数 $J(\theta)$ 的定义代入上面的公式中，不难推导出梯度下降算法公式：<br>$$<br>\begin{array}{c}<br>\theta_{0}=\theta_{0}-\frac{\alpha}{m} \sum_{i=1}^{m}\left(h\left(x^{(i)}\right)-y^{(j)}\right) \<br>\<br>\theta_{1}=\theta_{1}-\frac{\alpha}{m} \sum_{i=1}^{m}\left(\left(h\left(x^{(i)}\right)-y^{(i)}\right) x_{i}\right)<br>\end{array}<br>$$<br>公式中， $\alpha$  是学习率；m 是训练样本的个数: $h\left(x^{(i)}\right)-y^{(i)}$ 是模型预测值和真实值的误差。需要注意的是，针对</p><p> $\theta_{0}$ 和 $\theta_{1}$ 分别求出了其迭代公式，在 $\theta_{1}$ 的迭代公式里，累加器中还需要乘以 $x_{i}$, 具体参考扩展部分。</p><h2 id="多变量线性回归算法"><a href="#多变量线性回归算法" class="headerlink" title="多变量线性回归算法"></a>多变量线性回归算法</h2><p>实际应用中往往不止一个输入特征。熟悉了单变量线性回归算法后，我们来探讨一下多变量线性回归算法。</p><h3 id="预测函数-1"><a href="#预测函数-1" class="headerlink" title="预测函数"></a>预测函数</h3><p>上面介绍的单变量线性回归模型里只有一个输入特征，我们推广到更一般的情况，即多个输入特征。此时输出y的值由n个输入特征 $x_{1}, x_{2}, \ldots, x_{n}$ 决定。那么预测函数模型可以改写如下：</p><p>$$<br>h_{\theta}(x)=\theta_{0}+\theta_{1} x_{1}+\theta_{2} x_{2}+\ldots+\theta_{n} x_{n}<br>$$<br>假设 $x_{0}=1$，那么上面的公式可以重写为：<br>$$<br>h_{\theta}(x)=\sum_{j=0}^{n} \theta_{j} x_{j}<br>$$<br>其中，$\theta_{0}, \theta_{1}, \dots, \theta_{n}$ 统称为 $\theta$ , 是预测函数的参数。即一组 $\theta$ 值就决定了一个预测函数，记为 $h_{\theta}(x)$ , 为了简便起见，在不引起误解的情况下可以简写为 $h(x)$ 。理论上，预测函数有无穷多个，我们求解的目标就是找出一个最优的 $\theta$ 值。</p><h4 id="向量形式的预测函数"><a href="#向量形式的预测函数" class="headerlink" title="向量形式的预测函数"></a>向量形式的预测函数</h4><p>根据向量乘法运算法则，损失函数可重写为：</p><p>$$<br>h_{\theta}(x)=\left[\theta_{0}, \theta_{1}, \cdots, \theta_{n}\right]\left[\begin{array}{c}<br>x_{0} \<br>x_{1} \<br>\vdots \<br>x_{n}<br>\end{array}\right]=\theta^{T} x<br>$$<br>此处，依然假设 $x_{0}=1$， $x_{0}$ 称为模型偏置（bias）。</p><p>写成向量形式的预测函数有两个原因。一是因为简洁，二是因为在实现算法时，要用到数值计算里的矩阵运算来提高效率，比如 <code>Numpy</code> 库里的矩阵运算。</p><h4 id="向量形式的训练样本"><a href="#向量形式的训练样本" class="headerlink" title="向量形式的训练样本"></a>向量形式的训练样本</h4><p>假设输入特征的个数是n，即 $x_{1}, x_{2}, \ldots, x_{n}$ , 我们总共有 m 个训练样本，为了书写方便，假设 $x_{0}=1$。这样训练样本可以写成矩阵的形式，即矩阵里每一行都是一个训练样本，总共有 m 行，每行有 n+1 列。</p><blockquote><p>思考：为什么不是n列而是n+1列？答案是：把模型偏置 $x_{0}$也加入了训练样本里。最后把训练样本写成一个矩阵，如下：</p></blockquote><p>$$<br>\boldsymbol{X}=\left[\begin{array}{ccccc}<br>x_{0}^{(1)} &amp; x_{1}^{(1)} &amp; x_{2}^{(1)} &amp; \dots &amp; x_{n}^{(1)} \<br>x_{0}^{(2)} &amp; x_{1}^{(2)} &amp; x_{2}^{(2)} &amp; \dots &amp; x_{n}^{(2)} \<br>\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>x_{0}^{(m)} &amp; x_{1}^{(m)} &amp; x_{2}^{(m)} &amp; \cdots &amp; x_{n}^{(m)}<br>\end{array}\right], \theta=\left[\begin{array}{c}<br>\theta_{0} \<br>\theta_{1} \<br>\theta_{2} \<br>\vdots \<br>\theta_{n}<br>\end{array}\right]<br>$$</p><p>理解训练样本矩阵的关键在于理解这些上标和下标的含义。其中，带括号的上标表示样本序号，从1到m；下标表示特征序号，从0到n，其中 $x_{0}$ 为常数1。</p><blockquote><p>$x_{j}^{(i)}$ 表示第 i 个训练样本的第 j 个特征的值。而 $x^{(i)}$ 只有上标，则表示第 i 个训练样本所构成的列向量。</p></blockquote><p>综上，训练样本的预测值 $h_{\theta}(X)$ ，可以使用下面的矩阵运算公式：</p><p>$$<br>h_{\theta}(X)=X \theta<br>$$</p><h3 id="损失函数-1"><a href="#损失函数-1" class="headerlink" title="损失函数"></a>损失函数</h3><p>多变量线性回归算法的损失函数：</p><p>$$<br>J(\theta)=\frac{1}{2 m} \sum_{i=1}^{m}\left(h\left(x^{(i)}\right)-y^{(i)}\right)^{2}<br>$$<br>其中，模型参数 $\theta$ 为 n+1 维的向量，$h\left(x^{(i)}\right)-y^{(i)}$ 是预测值和实际值的差，这个形式和单变量线性回归算法的类似。</p><p>损失函数有其对应的矩阵形式：<br>$$<br>J(\theta)=\frac{1}{2 m}(X \theta-\vec{y})^{T}(X \theta-\vec{y})<br>$$<br>其中，X 为 $m \times(n+1)$ 维的训练样本矩阵；上标T表示转置矩阵；$\vec{y}$ 表示由所有的训练样本的输出 $y^{(i)}$ 构成的向量。这个公式的优势是：没有累加器，不需要循环，直接使用矩阵运算，就可以一次性计算出对特定的参数 $\theta$ 下模型的拟合损失。</p><h3 id="梯度下降算法-1"><a href="#梯度下降算法-1" class="headerlink" title="梯度下降算法"></a>梯度下降算法</h3><p>根据单变量线性回归算法的介绍，梯度下降的公式为：<br>$$<br>\theta_{j}=\theta_{j}-\alpha \frac{\partial}{\partial \theta_{j}} J(\theta)<br>$$<br>公式中，下标 j 是参数的序号，其值从 0 到 n； $\alpha$ 为学习率。把损失函数代入上式，利用偏导数计算法则，不难推导出梯度下降算法的参数迭代公式：<br>$$<br>\theta_{j}=\theta_{j}-\frac{\alpha}{m} \sum_{i=1}^{m}\left(\left(h\left(x^{(i)}\right)-y^{(i)}\right) x_{j}^{(i)}\right)<br>$$<br>我们可以对比一下单变量线性回归函数的参数迭代公式。实际上和多变量线性回归函数的参数迭代公式是一模一样的。惟一的区别就是因为 $x_{0}$ 为常数1，在单变量线性回归算法的参数迭代公式中省去了。</p><p>应用这个公式编写机器学习算法，一般步骤如下：</p><ul><li><p>确定学习率： $\alpha$ 太大可能会使损失函数无法收敛，太小则计算太多，机器学习算法效率就比较低。</p></li><li><p>参数初始化：比如让所有的参数都以1作为起始点，$\theta_{0}=1, \theta_{1}=1, \dots, \theta_{n}=1$，根据预测值和损失函数，就可以算出在参数起始位置的损失。需要注意的是，参数起始点可以根据实际情况灵活选择，以便让机器学习算法的性能更高，比如选择比较靠近极点的位置。</p></li><li><p>计算参数的下一组值：据梯度下降参数迭代公式，分别同时计算出新的 $\theta_{j}$ 值，进而得到新的预测函数 $h_{\theta}(x)$ 。再根据新的预测函数，代入损失函数就可以算出新的损失。</p></li><li><p>确定损失函数是否收敛：拿新的和旧的损失进行比较，看损失是不是变得越来越小。如果两次损失之间的差异小于误差范围，即说明已经非常靠近最小损失了，就可以近似地认为我们找到了最小损失。如果两次损失之间的差异在误差范围之外，重复步骤（3）继续计算下一组参数直到找到最优解。</p></li></ul><h2 id="模型优化"><a href="#模型优化" class="headerlink" title="模型优化"></a>模型优化</h2><p>线性回归模型常用的优化方法，包括增加多项式特征以及数据归一化处理等。</p><h3 id="多项式与线性回归"><a href="#多项式与线性回归" class="headerlink" title="多项式与线性回归"></a>多项式与线性回归</h3><p>当线性回归模型太简单导致欠拟合时，我们可以增加特征多项式来让线性回归模型更好地拟合数据。比如有两个特征  $x_{1}$ 和 $x_{2}$ ，可以增加两个特征的乘积 $x_{1} \times x_{2}$ 作为新特征  $x_{3}$ 。同理，我们也可以增加 $x_{1}^{2}$ 和 $x_{2}^{2}$  分别作为新特征  $x_{4}$ 和 $x_{5}$ 。</p><p>在 <code>scikit-learn</code> 里，线性回归是由类 <code>sklearn.learn_model.LinearRegression</code> 实现的，多项式由类<code>sklearn.preprocessing.PolynomialFeatures</code> 实现。那么要怎样添加多项式特征呢？我们需要用一个管道把两个类串起来，即用 <code>sklearn.pipeline.Pipeline</code> 把这两个模型串起来。</p><p>比如下面的函数就可以创建一个多项式拟合：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>linear_model <span class="token keyword">import</span> LinearRegression<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>preprocessing <span class="token keyword">import</span> PolynomialFeatures<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>pipeline <span class="token keyword">import</span> Pipeline<span class="token keyword">def</span> <span class="token function">polynomial_model</span><span class="token punctuation">(</span>degree<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    polynomial_features <span class="token operator">=</span> PolynomialFeatures<span class="token punctuation">(</span>degree<span class="token operator">=</span>degree<span class="token punctuation">,</span>include_bias<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>    linear_regression <span class="token operator">=</span> LinearRegression<span class="token punctuation">(</span>normalize<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 这是一个流水线，先增加多项式阶数，然后再用线性回归算法来拟合数据</span>    pipeline <span class="token operator">=</span> Pipeline<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">"polynomial_features"</span><span class="token punctuation">,</span> polynomial_features<span class="token punctuation">)</span><span class="token punctuation">,</span>                         <span class="token punctuation">(</span><span class="token string">"linear_regression"</span><span class="token punctuation">,</span> linear_regression<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> pipeline<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个 Pipeline 可以包含多个处理节点，在 scikit-learn 里，除了最后一个节点外，其他的节点都必须实现 fit() 方法和 transform() 方法，最后一个节点只需要实现 fit() 方法即可。当训练样本数据送进 Pipeline 里进行处理时，它会逐个调用节点的 fit() 方法和 transform() 方法，最后调用最后一个节点的 fit() 方法来拟合数据。管道的示意图如下所示：</p><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200630093109778.png" alt="image-20200630090937011"></p><h3 id="数据归一化"><a href="#数据归一化" class="headerlink" title="数据归一化"></a>数据归一化</h3><p>当线性回归模型有多个输入特征时，特别是使用多项式添加特征时，需要对数据进行归一化处理。比如，特征</p><p>$x_{1}$ 的范围在[1,4]之间，特征 $x_{2}$ 的范文在[1,2000]之间，这种情况下，可以让 $x_{1}$除以4来作为新特征 $x_{1}$，同时让 $x_{2}$ </p><p>除以2000来作为新特征 $x_{2}$ ，该过程称为特征缩放（feature scaling）。可以使用特征缩放来对训练样本进行归一化处理，处理后的特征范围在[0,1]之间。</p><ul><li>归一化处理的目的是让算法收敛更快，提升模型拟合过程中的计算效率。</li><li>进行归一化处理后，当有个新的样本需要计算预测值时，也需要先进行归一化处理，再通过模型来计算预测值，计算出来的预测值要再乘以归一化处理的系数，这样得到的数据才是真正的预测数据。</li><li>在 <code>scikit-learn</code> 里，使用 <code>LinearRegression</code> 进行线性回归时，可以指定 <code>normalize=True</code> 来对数据进行归一化处理。</li></ul><h2 id="示例1：使用线性回归算法拟合正弦函数"><a href="#示例1：使用线性回归算法拟合正弦函数" class="headerlink" title="示例1：使用线性回归算法拟合正弦函数"></a>示例1：使用线性回归算法拟合正弦函数</h2><p>首先生成200个在区间 $[2 \pi, 2 \pi]$ 内的正弦函数上的点，并给这些点加上一些随机的噪声。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> npn_dots <span class="token operator">=</span> <span class="token number">200</span>X <span class="token operator">=</span> np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2</span> <span class="token operator">*</span> np<span class="token punctuation">.</span>pi<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> np<span class="token punctuation">.</span>pi<span class="token punctuation">,</span> n_dots<span class="token punctuation">)</span>Y <span class="token operator">=</span> np<span class="token punctuation">.</span>sin<span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">0.2</span> <span class="token operator">*</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span>n_dots<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">0.1</span><span class="token comment" spellcheck="true"># 把一个n维向量转换成一个n*1维的矩阵</span>X <span class="token operator">=</span> X<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>Y <span class="token operator">=</span> Y<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 <code>PolynomialFeatures</code> 和 <code>Pipeline</code> 创建一个多项式拟合模型</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>linear_model <span class="token keyword">import</span> LinearRegression<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>preprocessing <span class="token keyword">import</span> PolynomialFeatures<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>pipeline <span class="token keyword">import</span> Pipeline<span class="token keyword">def</span> <span class="token function">polynomial_model</span><span class="token punctuation">(</span>degree<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    polynomial_features <span class="token operator">=</span> PolynomialFeatures<span class="token punctuation">(</span>degree<span class="token operator">=</span>degree<span class="token punctuation">,</span>include_bias<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>    linear_regression <span class="token operator">=</span> LinearRegression<span class="token punctuation">(</span>normalize<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    pipeline <span class="token operator">=</span> Pipeline<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">"polynomial_features"</span><span class="token punctuation">,</span> polynomial_features<span class="token punctuation">)</span><span class="token punctuation">,</span>                         <span class="token punctuation">(</span><span class="token string">"linear_regression"</span><span class="token punctuation">,</span> linear_regression<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> pipeline<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分别用2/3/5/10阶多项式来拟合数据集：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>metrics <span class="token keyword">import</span> mean_squared_errordegrees <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span>results <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> d <span class="token keyword">in</span> degrees<span class="token punctuation">:</span>    model <span class="token operator">=</span> polynomial_model<span class="token punctuation">(</span>degree<span class="token operator">=</span>d<span class="token punctuation">)</span>    model<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X<span class="token punctuation">,</span> Y<span class="token punctuation">)</span>    train_score <span class="token operator">=</span> model<span class="token punctuation">.</span>score<span class="token punctuation">(</span>X<span class="token punctuation">,</span> Y<span class="token punctuation">)</span>    mse <span class="token operator">=</span> mean_squared_error<span class="token punctuation">(</span>Y<span class="token punctuation">,</span> model<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">)</span>    results<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"model"</span><span class="token punctuation">:</span> model<span class="token punctuation">,</span> <span class="token string">"degree"</span><span class="token punctuation">:</span> d<span class="token punctuation">,</span> <span class="token string">"score"</span><span class="token punctuation">:</span> train_score<span class="token punctuation">,</span> <span class="token string">"mse"</span><span class="token punctuation">:</span> mse<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">for</span> r <span class="token keyword">in</span> results<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"degree: {}; train score: {}; mean squared error: {}"</span>          <span class="token punctuation">.</span>format<span class="token punctuation">(</span>r<span class="token punctuation">[</span><span class="token string">"degree"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> r<span class="token punctuation">[</span><span class="token string">"score"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> r<span class="token punctuation">[</span><span class="token string">"mse"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>算出每个模型拟合的评分，此外，使用 <code>mean_squared_error</code> 算出均方根误差，即实际的点和模型预点之间的距离，均方根误差越小说明模型拟合效果越好——上述代码的输出结果为：</p><pre class="line-numbers language-python"><code class="language-python">degree<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">;</span> train score<span class="token punctuation">:</span> <span class="token number">0.1543189069883787</span><span class="token punctuation">;</span> mean squared error<span class="token punctuation">:</span> <span class="token number">0.43058829267318416</span>degree<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">;</span> train score<span class="token punctuation">:</span> <span class="token number">0.2755383996826518</span><span class="token punctuation">;</span> mean squared error<span class="token punctuation">:</span> <span class="token number">0.3688679883773196</span>degree<span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">;</span> train score<span class="token punctuation">:</span> <span class="token number">0.8982707756590037</span><span class="token punctuation">;</span> mean squared error<span class="token punctuation">:</span> <span class="token number">0.051796609130712795</span>degree<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">;</span> train score<span class="token punctuation">:</span> <span class="token number">0.9935830575581858</span><span class="token punctuation">;</span> mean squared error<span class="token punctuation">:</span> <span class="token number">0.0032672603337543927</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>从输出结果可以看出，多项式阶数越高，拟合评分越高，均方根误差越小，拟合效果越好。</p><p>把不同模型的拟合效果在二维坐标上画出来，可以清楚地看到不同阶数的多项式的拟合效果：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">from</span> matplotlib<span class="token punctuation">.</span>figure <span class="token keyword">import</span> SubplotParamsplt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span>dpi<span class="token operator">=</span><span class="token number">200</span><span class="token punctuation">,</span>subplotpars<span class="token operator">=</span>SubplotParams<span class="token punctuation">(</span>hspace<span class="token operator">=</span><span class="token number">0.3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> i<span class="token punctuation">,</span>r <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>results<span class="token punctuation">)</span><span class="token punctuation">:</span>    fig <span class="token operator">=</span> plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>xlim<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">"LinearRegression degree={}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>r<span class="token punctuation">[</span><span class="token string">"degree"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>X<span class="token punctuation">,</span>Y<span class="token punctuation">,</span>s<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span>c<span class="token operator">=</span><span class="token string">'b'</span><span class="token punctuation">,</span>alpha<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>X<span class="token punctuation">,</span>r<span class="token punctuation">[</span><span class="token string">"model"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>predict<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">'r-'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 <code>SubplotParam</code>s 调整了子图的竖直间距，并且使用 <code>subplot()</code> 函数把4个模型的拟合情况都画在同一个图形上。上述代码的输出结果如下图所示：</p><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200630090937011.png" alt="image-20200630092742917"></p><p>在[-2π，2π]区间内，10阶多项式对数据拟合得非常好，我们可以试着画出这10阶模型在[-20,20]的区域内的曲线，观察一下该模型的曲线和正弦函数的差异。代码如下：</p><pre class="line-numbers language-python"><code class="language-python">plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span>dpi<span class="token operator">=</span><span class="token number">200</span><span class="token punctuation">)</span>X <span class="token operator">=</span> np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>Y <span class="token operator">=</span> np<span class="token punctuation">.</span>sin<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>model_10 <span class="token operator">=</span> results<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"model"</span><span class="token punctuation">]</span>plt<span class="token punctuation">.</span>xlim<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylim<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>X<span class="token punctuation">,</span>Y<span class="token punctuation">,</span><span class="token string">'b-'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>X<span class="token punctuation">,</span>model_10<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">'r-'</span><span class="token punctuation">)</span>dot1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token operator">*</span>np<span class="token punctuation">.</span>pi<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span>dot2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">*</span>np<span class="token punctuation">.</span>pi<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span>plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>dot1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dot1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>s<span class="token operator">=</span><span class="token number">50</span><span class="token punctuation">,</span>c<span class="token operator">=</span><span class="token string">'r'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>dot2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dot2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>s<span class="token operator">=</span><span class="token number">50</span><span class="token punctuation">,</span>c<span class="token operator">=</span><span class="token string">'r'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码的输出结果如下图：</p><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200630100257358.png" alt="image-20200630093109778"></p><p>从图中可以看出，10阶多项式模型只有在区间[-2π,2π]之间对正弦曲线拟合较好，在此区间以外，两者相差甚远。此案例告诉我们，每个模型都有自己的适用范围，在满足适用范围的基本前提下，要尽可能寻找拟合程度最高的模型来使用。</p><h2 id="示例2：预测房价"><a href="#示例2：预测房价" class="headerlink" title="示例2：预测房价"></a>示例2：预测房价</h2><p>本节使用 <code>scikit-learn</code> 自带的波士顿房价数据来训练模型，然后用模型来预测房价。</p><h3 id="输入特征"><a href="#输入特征" class="headerlink" title="输入特征"></a>输入特征</h3><p>房价和哪些因素有关？很多人可能对这个问题特别敏感，随时可以列出很多，如房子面子、房子地理位置、周边教育资源、周边商业资源、房子朝向、年限、小区情况等。在 <code>scikit-learn</code>的波士顿房价数据集里，它总共收集了13个特征，具体如下：</p><ul><li><p>CRIM：城镇人均犯罪率。</p></li><li><p>ZN：城镇超过25000平方英尺的住宅区域的占地比例。</p></li><li><p>INDUS：城镇非零售用地占地比例。</p></li><li><p>CHAS：是否靠近河边，1为靠近，0为远离。</p></li><li><p>NOX：一氧化氮浓度</p></li><li><p>RM：每套房产的平均房间个数。</p></li><li><p>AGE：在1940年之前就盖好，且业主自住的房子的比例。</p></li><li><p>DIS：与波士顿市中心的距离。</p></li><li><p>RAD：周边高速公路的便利性指数。</p></li><li><p>TAX：每10000美元的财产税率。</p></li><li><p>PTRATIO：小学老师的比例。</p></li><li><p>B：城镇黑人的比例。</p></li><li><p>LSTAT：地位较低的人口比例。</p></li></ul><p>从这些指标里可以看到中美指标的一些差异。当然，这个数据是在1993年之前收集的，可能和现在会有差异。不要小看了这些指标，实际上一个模型的好坏和输入特征的选择关系密切。大家可以思考一下，如果要在中国预测房价，你会收集哪些特征数据？这些特征数据的可获得性如何？收集成本多高？</p><p>先导入数据：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>datasets <span class="token keyword">import</span> load_bostonboston <span class="token operator">=</span> load_boston<span class="token punctuation">(</span><span class="token punctuation">)</span>X <span class="token operator">=</span> boston<span class="token punctuation">.</span>datay <span class="token operator">=</span> boston<span class="token punctuation">.</span>target<span class="token keyword">print</span><span class="token punctuation">(</span>X<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># (506, 13)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>表明这个数据集有506个样本，每个样本有13个特征。整个训练样本放在一个506*13的矩阵里。可以通过X[0]来查看一个样本数据：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>X<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">6.320e-03</span><span class="token punctuation">,</span> <span class="token number">1.800e+01</span><span class="token punctuation">,</span> <span class="token number">2.310e+00</span><span class="token punctuation">,</span> <span class="token number">0.000e+00</span><span class="token punctuation">,</span> <span class="token number">5.380e-01</span><span class="token punctuation">,</span> <span class="token number">6.575e+00</span><span class="token punctuation">,</span>       <span class="token number">6.520e+01</span><span class="token punctuation">,</span> <span class="token number">4.090e+00</span><span class="token punctuation">,</span> <span class="token number">1.000e+00</span><span class="token punctuation">,</span> <span class="token number">2.960e+02</span><span class="token punctuation">,</span> <span class="token number">1.530e+01</span><span class="token punctuation">,</span> <span class="token number">3.969e+02</span><span class="token punctuation">,</span>       <span class="token number">4.980e+00</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>还可以通过 <code>boston.features_names</code> 来查看这些特征的标签：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>boston<span class="token punctuation">.</span>feature_names<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出如下：</p><pre class="line-numbers language-python"><code class="language-python">array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'CRIM'</span><span class="token punctuation">,</span> <span class="token string">'ZN'</span><span class="token punctuation">,</span> <span class="token string">'INDUS'</span><span class="token punctuation">,</span> <span class="token string">'CHAS'</span><span class="token punctuation">,</span> <span class="token string">'NOX'</span><span class="token punctuation">,</span> <span class="token string">'RM'</span><span class="token punctuation">,</span> <span class="token string">'AGE'</span><span class="token punctuation">,</span> <span class="token string">'DIS'</span><span class="token punctuation">,</span> <span class="token string">'RAD'</span><span class="token punctuation">,</span>       <span class="token string">'TAX'</span><span class="token punctuation">,</span> <span class="token string">'PTRATIO'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'LSTAT'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token string">'&lt;U7'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们可以把特征和数值对应起来，观察一下数据。</p><h3 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h3><p>在 <code>scikit-learn</code> 里，<code>LinearRegression</code> 类实现了线性回归算法。在对模型进行训练之前，我们需要先把数据集分成两份，以便评估算法的准确性。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> train_test_splitX_train<span class="token punctuation">,</span>X_test<span class="token punctuation">,</span>y_train<span class="token punctuation">,</span>y_test<span class="token operator">=</span>train_test_split<span class="token punctuation">(</span>X<span class="token punctuation">,</span>y<span class="token punctuation">,</span>test_size<span class="token operator">=</span><span class="token number">0.2</span><span class="token punctuation">,</span>random_state<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>由于数据量比较小，我们只选了20%的样本来作为测试数据集。接着，训练模型并测试模型的准确性评分：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> time<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>linear_model <span class="token keyword">import</span> LinearRegressionmodel <span class="token operator">=</span> LinearRegression<span class="token punctuation">(</span><span class="token punctuation">)</span>start <span class="token operator">=</span> time<span class="token punctuation">.</span>process_time<span class="token punctuation">(</span><span class="token punctuation">)</span>model<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span>y_train<span class="token punctuation">)</span>train_score <span class="token operator">=</span> model<span class="token punctuation">.</span>score<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span>y_train<span class="token punctuation">)</span>test_score <span class="token operator">=</span> model<span class="token punctuation">.</span>score<span class="token punctuation">(</span>X_test<span class="token punctuation">,</span>y_test<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"elaspe:{0:.6f};train_score:{1:0.6f};test_score:{2:.6f}"</span>      <span class="token punctuation">.</span>format<span class="token punctuation">(</span>time<span class="token punctuation">.</span>process_time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>start<span class="token punctuation">,</span>train_score<span class="token punctuation">,</span>test_score<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们顺便统计了模型的训练时间，除此之外，统计模型对训练样本的准确性得分（即对训练样本拟合的好坏程度）<code>train_score</code>，还测试了模型对测试样本的得分test_score。运行结果如下：</p><pre class="line-numbers language-python"><code class="language-python">elaspe<span class="token punctuation">:</span><span class="token number">0.000000</span><span class="token punctuation">;</span>train_score<span class="token punctuation">:</span><span class="token number">0.723941</span><span class="token punctuation">;</span>test_score<span class="token punctuation">:</span><span class="token number">0.795262</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>从得分情况来看，模型的拟合效果一般，还有没有办法来优化模型的拟合效果呢？</p><h3 id="模型优化-1"><a href="#模型优化-1" class="headerlink" title="模型优化"></a>模型优化</h3><p>首先观察一下数据，特征数据的范围相差比较大，最小的在$10^{-3}$级别，而最大的在$10^{2}$级别，看来我们需要先把数据进行归一化处理。归一化处理最简单的方式是，创建线性回归模型时增加normalize=True参数：</p><pre class="line-numbers language-python"><code class="language-python">model <span class="token operator">=</span> LinearRegression<span class="token punctuation">(</span>normalize<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当然，数据归一化处理只会加快算法收敛速度，优化算法训练的效率，无法提升算法的准确性。</p><p>怎么样优化模型的准确性呢？我们回到训练分数上来，可以观察到模型针对训练样本的评分比较低（train_score:0.723941），即模型对训练样本的拟合成本比较高，这是一个典型的欠拟合现象。回忆我们之前介绍的优化欠拟合模型的方法，一是挖掘更多的输入特征，而是增加多项式特征。在我们这个例子里，通过使用低成本的方案——即增加多项式特征来看能否优化模型的性能。增加多项式特征，其实就是增加模型的复杂度。</p><p>我们使用之前创建多项式模型的函数 <code>polynomial_model</code>，接着，我们使用二阶多项式来拟合数据：</p><pre class="line-numbers language-python"><code class="language-python">model <span class="token operator">=</span> polynomial_model<span class="token punctuation">(</span>degree<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>start <span class="token operator">=</span> time<span class="token punctuation">.</span>process_time<span class="token punctuation">(</span><span class="token punctuation">)</span>model<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span> y_train<span class="token punctuation">)</span>train_score <span class="token operator">=</span> model<span class="token punctuation">.</span>score<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span> y_train<span class="token punctuation">)</span>test_score <span class="token operator">=</span> model<span class="token punctuation">.</span>score<span class="token punctuation">(</span>X_test<span class="token punctuation">,</span> y_test<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"elaspe:{0:.6f};train_score:{1:0.6f};test_score:{2:.6f}"</span>      <span class="token punctuation">.</span>format<span class="token punctuation">(</span>time<span class="token punctuation">.</span>process_time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">,</span> train_score<span class="token punctuation">,</span> test_score<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果是：</p><pre class="line-numbers language-python"><code class="language-python">elaspe<span class="token punctuation">:</span><span class="token number">0.078125</span><span class="token punctuation">;</span>train_score<span class="token punctuation">:</span><span class="token number">0.930547</span><span class="token punctuation">;</span>test_score<span class="token punctuation">:</span><span class="token number">0.860049</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>训练样本分数和测试分数都提高了，看来模型确实得到了优化。我们可以把多项式改为3阶看一下效果：</p><pre class="line-numbers language-python"><code class="language-python">elaspe<span class="token punctuation">:</span><span class="token number">0.093750</span><span class="token punctuation">;</span>train_score<span class="token punctuation">:</span><span class="token number">1.000000</span><span class="token punctuation">;</span>test_score<span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">105.548323</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>改为3阶多项式后，针对训练样本的分数达到了1，而针对测试样本的分数确实负数，说明这个模型过拟合了。</p><p>思考：我们总共有13个输入特征，从一阶多项式变为二阶多项式，输入特征个数增加了多少个？<br> 参考：二阶多项式共有：13个单一的特征，$C_{13}^{2}=78$ 个两两配对的特征，13个各自平方的特征，共计104个特征。比一阶多项式的13个特征增加了91个特征。</p><h3 id="学习曲线"><a href="#学习曲线" class="headerlink" title="学习曲线"></a>学习曲线</h3><p>更好的方法是画出学习曲线，这样对模型的状态以及优化的方向就一目了然。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">from</span> utils <span class="token keyword">import</span> plot_learning_curve<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> ShuffleSplitcv <span class="token operator">=</span> ShuffleSplit<span class="token punctuation">(</span>n_splits<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span>test_size<span class="token operator">=</span><span class="token number">0.2</span><span class="token punctuation">,</span>random_state<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>dpi<span class="token operator">=</span><span class="token number">200</span><span class="token punctuation">)</span>title <span class="token operator">=</span> <span class="token string">'Learning Curves (degree={0})'</span>degrees <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>start <span class="token operator">=</span> time<span class="token punctuation">.</span>process_time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>degrees<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    plot_learning_curve<span class="token punctuation">(</span>plt<span class="token punctuation">,</span>polynomial_model<span class="token punctuation">(</span>degrees<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>title<span class="token punctuation">.</span>format<span class="token punctuation">(</span>degrees<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                        X<span class="token punctuation">,</span>y<span class="token punctuation">,</span>ylim<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0.01</span><span class="token punctuation">,</span><span class="token number">1.01</span><span class="token punctuation">)</span><span class="token punctuation">,</span>cv<span class="token operator">=</span>cv<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'elaspe:{0:.6f}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>time<span class="token punctuation">.</span>process_time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出如下：</p><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200630092742917.png" alt="image-20200630100257358"></p><p>从学习曲线中可以看出，一阶多项式欠拟合，因为针对训练样本的分数比较低；而三阶多项式过拟合，因为针对训练样本的分数达到1，却看不到交叉验证数据集的分数。针对二阶多项式拟合的情况，虽然比一阶多项式的效果好，但从图中可以明显地看出来，针对训练数据集的分数和针对交叉验证数据集的分数之间的间隔比较大，这说明训练样本数量不够，我们应该去采集更多的数据，以提高模型的准确性。</p><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><p>本节内容涉及到较多的数学知识，特别是矩阵和偏导数运算法则。如果阅读起来有困难，可以先跳过。如果有一定数学基础，这些知识对理解算法的实现细节及算法的效率有较大的帮助。</p><h3 id="公式推导的数学基础"><a href="#公式推导的数学基础" class="headerlink" title="公式推导的数学基础"></a>公式推导的数学基础</h3><p>AI的数学基础最主要的是高等数学、线性代数、概率论与数理统计这三门课程。下面是简易的入门文章供参考</p><ul><li>高等数学 <a href="https://zhuanlan.zhihu.com/p/36311622" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/36311622</a></li><li>线性代数 <a href="https://zhuanlan.zhihu.com/p/36584206" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/36584206</a></li><li>概率论与数理统计 <a href="https://zhuanlan.zhihu.com/p/36584335" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/36584335</a></li></ul><h3 id="随机梯度下降算法"><a href="#随机梯度下降算法" class="headerlink" title="随机梯度下降算法"></a>随机梯度下降算法</h3><p>本章介绍的梯度下降算法迭代公式称为批量梯度下降算法（Batch Gradient Descent，简称BGD），用它对参数进行一次迭代运算，需要遍历所有的训练数据集。当训练数据集比较大时，其算法的效率会比较低。考虑另外一个算法：<br>$$<br>\theta_{j}=\theta_{j}-\alpha\left(\left(h\left(x^{(i)}\right)-y^{(i)}\right) x_{j}^{(i)}\right)<br>$$<br> 这个算法的关键点是把累加器去掉，不去遍历所有的数据集，而是改成每次随机地从训练数据集中取一个数据进行参数迭代计算，这就是随机梯度下降算法（Stochastic Gradient Descent，简称SGD）。随机梯度下降算法可以大大提高模型训练的效率。</p><h3 id="正规方程"><a href="#正规方程" class="headerlink" title="正规方程"></a>正规方程</h3><p>梯度下降算法通过不断地迭代，从而不停地逼近成本函数的最小值来求解模型的参数。另外一个方法是直接计算成本函数的微分，令微分算子为0，求解这个方程，即可得到线性回归的解。<br> 线性回归算法的损失函数：<br>$$<br>J(\theta)=\frac{1}{2 m} \sum_{i=0}^{n}\left(h_{\theta}\left(x^{(i)}\right)-y^{(i)}\right)^{2}<br>$$<br>成本函数的“斜率”为0的点，即为模型参数的解。令$\frac{\partial}{\partial \theta} J(\theta)=0$，求解这个方程最终可以得到模型参数：<br>$$<br>\theta=\left(X^{T} X\right)^{-1} X^{T} y<br>$$<br>这就是我们的正规方程。它通过矩阵运算，直接从训练样本里求出参数θ的值。其中X为训练样本的矩阵形式，它是m×n的矩阵，y是训练样本的结果数据，它是个m维列向量。方程求解过程可参阅<a href="https://baike.baidu.com/item/%E6%AD%A3%E8%A7%84%E6%96%B9%E7%A8%8B/10001812?fr=aladdin" target="_blank" rel="noopener">百度百科</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> ML算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scikit-learn系列二：K-近邻</title>
      <link href="/2020/06/29/scikit-learn-xi-lie-er-k-jin-lin/"/>
      <url>/2020/06/29/scikit-learn-xi-lie-er-k-jin-lin/</url>
      
        <content type="html"><![CDATA[<h2 id="项目地址传送门，欢迎-star-和-fork-！"><a href="#项目地址传送门，欢迎-star-和-fork-！" class="headerlink" title="项目地址传送门，欢迎 star 和 fork ！"></a>项目地址<a href="https://github.com/DongZhouGu/scikit-learn-ml" target="_blank" rel="noopener">传送门</a>，欢迎 star 和 fork ！</h2><h2 id="KNN-概述"><a href="#KNN-概述" class="headerlink" title="KNN 概述"></a>KNN 概述</h2><p>KNN（K-Nearest Neighbor，K-近邻算法）算法是一种<strong>有监督</strong>的机器学习算法，可以解决分类问题，也可以解决回归问题。</p><blockquote><p><strong>一句话总结: 近朱者赤近墨者黑！</strong> </p></blockquote><p>k -近邻算法的输入为实例的特征向量，对应于特征空间的点；输出为实例的类别，可以取多类。k 近邻算法假设给定一个训练数据集，其中的实例类别已定。分类时，对新的实例，根据其 k 个最近邻的训练实例的类别，通过多数表决等方式进行预测。因此，k近邻算法不具有显式的学习过程。</p><h2 id="KNN算法原理"><a href="#KNN算法原理" class="headerlink" title="KNN算法原理"></a>KNN算法原理</h2><p>K-近邻算法的核心思想是未标记样本的类别，由距离其最近的 K 个邻居投票来决定。</p><p>假设，我们有一个已经标记的数据集，即已经知道了数据集中每个样本所属的类别。此时，有一个未标记的数据样本，我们的任务是预测出这个数据样本所属的类别。<strong>K-近邻算法的原理是，计算待标记的数据样本和数据集中每个样本的距离，取距离最近的K个样本。</strong>待标记的数据样本所属的类别，就由这K个距离最近的样本投票产生。</p><blockquote><p>KNN工作原理</p></blockquote><p>假设X_test为待标记的数据样本，X_train为已标记的数据集，算法原理的伪代码如下：</p><ul><li>遍历 X_train 中的所有样本，计算每个样本与 X_test 的距离，并把距离保存在 Distance 数组中。</li><li>对 Distance 数组进行排序，取距离最近的K个点，记为 X_knn 。</li><li>在 X_knn 中统计每个类别的个数，即 class0 在 X_knn 中有几个样本，class1 在 X_knn 中有几个样本等。</li><li>待标记样本的类别，就是在 X_knn 中样本数最多的那个类别。</li></ul><blockquote><p>KNN算法优缺点</p></blockquote><ul><li>优点：准确度高，对异常值和噪声有较高的容忍度。</li><li>缺点：计算复杂度高、空间复杂度高，从算法原理可以看出，每次对一个未标记样本进行分类时，都需要全部计算一遍距离。</li></ul><blockquote><p>KNN算法参数</p></blockquote><p>其算法参数是K，参数选择需要根据数据来决定。K值越大，模型的偏差越大，对噪声数据越不敏感，当K值很大时，可能造成模型欠拟合；K值越小，模型的方差就会越大，当K值太小，就会造成模型过拟合。</p><blockquote><p>KNN算法变种</p></blockquote><p>K-近邻算法有一些变种，其中之一就是可以增加邻居的权重。默认情况下，在计算距离时，都是使用相同的权重。实际上，我们可以针对不同的邻居指定不同的权重，如距离越近权重越高。这个可以通过指定算法的weights参数来实现。</p><p>另外一个变种是，使用一定半径内的点取代距离最近的K个点。在 <code>scikit-learn</code> 里，<code>RadiusNeighborsClassifier</code> 类实现了这个算法的变种。当数据采样不均匀时，该算法变种可以取得更好的性能。</p><h2 id="KNN-项目案例"><a href="#KNN-项目案例" class="headerlink" title="KNN 项目案例"></a>KNN 项目案例</h2><h3 id="案例1-使用KNN算法进行分类"><a href="#案例1-使用KNN算法进行分类" class="headerlink" title="案例1: 使用KNN算法进行分类"></a>案例1: 使用KNN算法进行分类</h3><p>完整代码地址：</p><p>在 <code>scikit-learn</code>里，使用K-近邻算法进行分类处理的是 <code>sklearn.neightbors.KNeightborsClassifier</code> 类。</p><h4 id="rainbow-生成数据集"><a href="#rainbow-生成数据集" class="headerlink" title=":rainbow:   生成数据集"></a>:rainbow:   生成数据集</h4><p>我们使用 <code>sklearn.datasets.samples_generator</code> 包下的 <code>make_blobs()</code> 函数来生成数据集，这里生成60个训练样本，这些样本分布在 <code>centers</code> 参数指定的中心点的周围。<code>cluster_std</code> 是标准差，用来指明生成的点分布的松散程度。生成的训练数据集放在变量X里面，数据集的类别标记放在 y 里面。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>datasets <span class="token keyword">import</span> make_blobs<span class="token comment" spellcheck="true"># 生成数据</span>centers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span>X<span class="token punctuation">,</span>y <span class="token operator">=</span> make_blobs<span class="token punctuation">(</span>n_samples<span class="token operator">=</span><span class="token number">60</span><span class="token punctuation">,</span>centers<span class="token operator">=</span>centers<span class="token punctuation">,</span>random_state<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>cluster_std<span class="token operator">=</span><span class="token number">0.60</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>X:  [[ 1.59652373  1.7842681 ] ,[-1.08033247 2.88161526],…]共60个点的横纵坐标</p><p>y: [1 0 0 1 0 1 1 0 2…1 2 0 1] 共60个点的类别，用0，1，2分别表示以哪个中心聚合</p></blockquote><p>使用 <code>matplotlib</code> 库，它可以很容易地把生成的点画出来：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> npplt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>dpi<span class="token operator">=</span><span class="token number">144</span><span class="token punctuation">)</span>c <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>centers<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># cmap就是指matplotlib.colors.Colormap,一个包含三列矩阵的色彩映射表</span><span class="token comment" spellcheck="true"># 使用c和cmap来映射颜色，s为形状的大小</span>plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>X<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>X<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>c<span class="token operator">=</span>y<span class="token punctuation">,</span>s<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">,</span>cmap<span class="token operator">=</span><span class="token string">'cool'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>c<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>c<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>s<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">,</span>marker<span class="token operator">=</span><span class="token string">'*'</span><span class="token punctuation">,</span>c<span class="token operator">=</span><span class="token string">'black'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200628191906466.png"><p>这些点的分布情况在坐标轴上一目了然，其中五角星的点即各个类别的中心点。</p><h4 id="rainbow-训练算法"><a href="#rainbow-训练算法" class="headerlink" title=":rainbow: 训练算法"></a>:rainbow: 训练算法</h4><p>使用 <code>KNeighborsClassifier</code> 来对算法进行训练，我们选择的参数是 <code>K=5</code></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>neighbors <span class="token keyword">import</span> KNeighborsClassifierk <span class="token operator">=</span> <span class="token number">5</span>clf <span class="token operator">=</span> KNeighborsClassifier<span class="token punctuation">(</span>n_neighbors<span class="token operator">=</span>k<span class="token punctuation">)</span>clf<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>KNeighborsClassifier</code>的参数细节为：</p><pre class="line-numbers language-python"><code class="language-python">KNeighborsClassifier<span class="token punctuation">(</span>algorithm<span class="token operator">=</span><span class="token string">'auto'</span><span class="token punctuation">,</span> leaf_size<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">,</span> metric<span class="token operator">=</span><span class="token string">'minkowski'</span><span class="token punctuation">,</span>           metric_params<span class="token operator">=</span>None<span class="token punctuation">,</span> n_jobs<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> n_neighbors<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span> p<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>           weights<span class="token operator">=</span><span class="token string">'uniform'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="rainbow-对样本进行预测"><a href="#rainbow-对样本进行预测" class="headerlink" title=":rainbow:  对样本进行预测"></a>:rainbow:  对样本进行预测</h4><p>我们要预测的样本是[0,2]，使用 <code>kneighbors()</code> 方法，把这个样本周围距离最近的5个点取出来。取出来的点是训练样本X里的索引，从0开始计算。<br> 注意：<code>kneighbors()</code>接收一个二维数组作为参数，所以 <code>X_sample</code> 需要变成二维。</p><pre class="line-numbers language-python"><code class="language-python">X_sample <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>X_sample <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>X_sample<span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#[[0 2]]</span>y_sample <span class="token operator">=</span> clf<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>X_sample<span class="token punctuation">)</span>neighbors <span class="token operator">=</span> clf<span class="token punctuation">.</span>kneighbors<span class="token punctuation">(</span>X_sample<span class="token punctuation">,</span>return_distance<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#[[16 20 48  6 23]]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="rainbow-标记最近的5个点"><a href="#rainbow-标记最近的5个点" class="headerlink" title=":rainbow:  标记最近的5个点"></a>:rainbow:  标记最近的5个点</h4><p>把待预测的样本以及和其最近的5个点标记出来</p><pre class="line-numbers language-python"><code class="language-python">plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>dpi<span class="token operator">=</span><span class="token number">144</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>X<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> X<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> c<span class="token operator">=</span>y<span class="token punctuation">,</span> s<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">,</span> cmap<span class="token operator">=</span><span class="token string">'cool'</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 样本</span>plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>c<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> c<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> s<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">,</span> marker<span class="token operator">=</span><span class="token string">'^'</span><span class="token punctuation">,</span> c<span class="token operator">=</span><span class="token string">'k'</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># 中心点</span>plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>X_sample<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>X_sample<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>marker<span class="token operator">=</span><span class="token string">"x"</span><span class="token punctuation">,</span> s<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">,</span> cmap<span class="token operator">=</span><span class="token string">'cool'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#待预测的点</span><span class="token comment" spellcheck="true">#预测点与距离最近的5个样本的连线</span><span class="token keyword">for</span> i <span class="token keyword">in</span> neighbors<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>    plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span>X<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>X_sample<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span>X<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>X_sample<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'k--'</span><span class="token punctuation">,</span>linewidth<span class="token operator">=</span><span class="token number">0.6</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200628204257514.png" alt=""></p><h3 id="案例2-使用KNN算法进行回归拟合"><a href="#案例2-使用KNN算法进行回归拟合" class="headerlink" title="案例2: 使用KNN算法进行回归拟合"></a>案例2: 使用KNN算法进行回归拟合</h3><p>分类问题的预测值是离散的，我们也可以使用 KNN 算法对连续区间内的数值进行预测，即进行回归拟合。在<code>scikit-learn</code>里面，使用KNN算法进行回归拟合的实现是 <code>sklearn.neighbors.KNeighborsRegressor</code> 类。</p><h4 id="rainbow-生成数据集-1"><a href="#rainbow-生成数据集-1" class="headerlink" title=":rainbow:  生成数据集"></a>:rainbow:  生成数据集</h4><p>在余弦曲线的基础上加入了噪声：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> npn_dots <span class="token operator">=</span> <span class="token number">40</span><span class="token comment" spellcheck="true"># 生成40行1列的服从“0~5”均匀分布的随机样本</span>X <span class="token operator">=</span> <span class="token number">5</span> <span class="token operator">*</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span>n_dots<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>y <span class="token operator">=</span> np<span class="token punctuation">.</span>cos<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">.</span>flatten<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 生成40行1列的服从“-0.1~0.1”均匀分布的随机误差</span>y <span class="token operator">+=</span> <span class="token number">0.2</span> <span class="token operator">*</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span>n_dots<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">0.1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="rainbow-训练算法-1"><a href="#rainbow-训练算法-1" class="headerlink" title=":rainbow:  训练算法"></a>:rainbow:  训练算法</h4><p>使用 <code>KNeighborsRegressor</code> 来训练模型：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>neighbors <span class="token keyword">import</span> KNeighborsRegressork <span class="token operator">=</span> <span class="token number">5</span>knn <span class="token operator">=</span> KNeighborsRegressor<span class="token punctuation">(</span>k<span class="token punctuation">)</span>knn<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>KNeighborsRegressor</code>方法的参数细节为：</p><pre class="line-numbers language-python"><code class="language-python">KNeighborsRegressor<span class="token punctuation">(</span>algorithm<span class="token operator">=</span><span class="token string">'auto'</span><span class="token punctuation">,</span> leaf_size<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">,</span> metric<span class="token operator">=</span><span class="token string">'minkowski'</span><span class="token punctuation">,</span>          metric_params<span class="token operator">=</span>None<span class="token punctuation">,</span> n_jobs<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> n_neighbors<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span> p<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>          weights<span class="token operator">=</span><span class="token string">'uniform'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以使用 <code>score()</code>方法 计算拟合曲线对训练样本的拟合准确性：</p><pre class="line-numbers language-python"><code class="language-python">knn<span class="token punctuation">.</span>score<span class="token punctuation">(</span>X<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token number">0.9596828473009764</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="rainbow-回归拟合"><a href="#rainbow-回归拟合" class="headerlink" title=":rainbow:  回归拟合"></a>:rainbow:  回归拟合</h4><p> 一个常用的方法是，在X轴上的指定区域生成足够多的点，针对这些足够密集的点，使用训练出来的模型进行预测，得到预测值y_pred，然后在坐标轴上，把所有的预测点连接起来，这样就画出了拟合曲线。<br> 生成足够密集的点并进行预测：</p><pre class="line-numbers language-python"><code class="language-python">T <span class="token operator">=</span> np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>newaxis<span class="token punctuation">]</span>y_pred <span class="token operator">=</span> knn<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>T<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>把这些预测点连起来，构成拟合曲线：</p><pre class="line-numbers language-python"><code class="language-python">plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>dpi<span class="token operator">=</span><span class="token number">144</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>X<span class="token punctuation">,</span>y<span class="token punctuation">,</span>c<span class="token operator">=</span><span class="token string">'g'</span><span class="token punctuation">,</span>label<span class="token operator">=</span><span class="token string">'data'</span><span class="token punctuation">,</span>s<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>T<span class="token punctuation">,</span>y_pred<span class="token punctuation">,</span>c<span class="token operator">=</span><span class="token string">'k'</span><span class="token punctuation">,</span>label<span class="token operator">=</span><span class="token string">'prediction'</span><span class="token punctuation">,</span>lw<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>axis<span class="token punctuation">(</span><span class="token string">'tight'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'KNeighborsRegressor (k = %i)'</span> <span class="token operator">%</span> k<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终生成的拟合曲线和训练样本数据如图，拟合出来确实和 cos 曲线相似。</p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200628223010274.png" style="zoom: 67%;"><h3 id="案例3-使用KNN算法预测糖尿病"><a href="#案例3-使用KNN算法预测糖尿病" class="headerlink" title="案例3: 使用KNN算法预测糖尿病"></a>案例3: 使用KNN算法预测糖尿病</h3><p>本节使用KNN算法及其变种，对Pima印第安人的糖尿病进行预测。数据来源<a href="">kaggle.com</a>大家可以自己去下载。也可以使用 <a href="./pima-indians-diabetes/diabetes.csv">仓库文件</a>。</p><h4 id="rainbow-加载数据集"><a href="#rainbow-加载数据集" class="headerlink" title=":rainbow:加载数据集"></a>:rainbow:加载数据集</h4><p>使用Pandas加载数据：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pddata <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'./pima-indians-diabetes/diabetes.csv'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'dataset shape {}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>data<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>head<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>输出如下：</p><pre class="line-numbers language-python"><code class="language-python">dataset shape <span class="token punctuation">(</span><span class="token number">768</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">23</span><span class="token punctuation">]</span><span class="token punctuation">:</span>Pregnancies Glucose BloodPressure   SkinThickness   Insulin BMI DiabetesPedigreeFunction    Age Outcome<span class="token number">0</span>   <span class="token number">6</span>   <span class="token number">148</span> <span class="token number">72</span>  <span class="token number">35</span>  <span class="token number">0</span>   <span class="token number">33.6</span>    <span class="token number">0.627</span>   <span class="token number">50</span>  <span class="token number">1</span><span class="token number">1</span>   <span class="token number">1</span>   <span class="token number">85</span>  <span class="token number">66</span>  <span class="token number">29</span>  <span class="token number">0</span>   <span class="token number">26.6</span>    <span class="token number">0.351</span>   <span class="token number">31</span>  <span class="token number">0</span><span class="token number">2</span>   <span class="token number">8</span>   <span class="token number">183</span> <span class="token number">64</span>  <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">23.3</span>    <span class="token number">0.672</span>   <span class="token number">32</span>  <span class="token number">1</span><span class="token number">3</span>   <span class="token number">1</span>   <span class="token number">89</span>  <span class="token number">66</span>  <span class="token number">23</span>  <span class="token number">94</span>  <span class="token number">28.1</span>    <span class="token number">0.167</span>   <span class="token number">21</span>  <span class="token number">0</span><span class="token number">4</span>   <span class="token number">0</span>   <span class="token number">137</span> <span class="token number">40</span>  <span class="token number">35</span>  <span class="token number">168</span> <span class="token number">43.1</span>    <span class="token number">2.288</span>   <span class="token number">33</span>  <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从打印出的信息可以看到，这个数据集一共有 768 个样本、8 个特征、1 个标签：</p><p><code>Pregnancies</code>：怀孕的次数</p><p><code>Glucose</code>：血浆葡萄糖浓度，采用 2 小时口服葡萄糖耐量试验测得</p><p><code>BloodPressure</code>：舒张压（毫米汞柱）</p><p><code>SkinThickness</code>：肱三头肌皮肤褶皱厚度（毫米）</p><p><code>Insulin</code>：两个小时血清胰岛素（ μU /毫升）</p><p><code>BMI</code>：身体质量指数，体重除以身高的平方</p><p><code>DiabetesPedigreeFunction</code>：糖尿病血统指数，糖尿病和家庭遗传相关</p><p><code>Age</code>：年龄</p><p><code>Outcome</code>：0表示没有糖尿病，1表示有糖尿病</p><p> 我们可以进一步观察数据集里的阳性和阴性样本的个数：</p><pre class="line-numbers language-python"><code class="language-python">data<span class="token punctuation">.</span>groupby<span class="token punctuation">(</span><span class="token string">'Outcome'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出为：</p><pre class="line-numbers language-python"><code class="language-python">Outcome<span class="token number">0</span>    <span class="token number">500</span><span class="token number">1</span>    <span class="token number">268</span>dtype<span class="token punctuation">:</span> int64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其中，阴性样本500例，阳性样本268例。</p><h4 id="rainbow-处理数据集"><a href="#rainbow-处理数据集" class="headerlink" title=":rainbow: 处理数据集"></a>:rainbow: 处理数据集</h4><p> 接着需要对数据集进行简单处理，把8个特征值分离出来，作为训练数据集，把Outcome列分离出来作为目标值。然后，把数据集划分为训练数据集和测试数据集。</p><pre class="line-numbers language-python"><code class="language-python">X <span class="token operator">=</span> data<span class="token punctuation">.</span>iloc<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span>Y <span class="token operator">=</span> data<span class="token punctuation">.</span>iloc<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> train_test_splitX_train<span class="token punctuation">,</span>X_test<span class="token punctuation">,</span>Y_train<span class="token punctuation">,</span>Y_test<span class="token operator">=</span>train_test_split<span class="token punctuation">(</span>X<span class="token punctuation">,</span>Y<span class="token punctuation">,</span>test_size<span class="token operator">=</span><span class="token number">0.2</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>X_train<span class="token punctuation">.</span>shape<span class="token punctuation">,</span> X_test<span class="token punctuation">.</span>shape<span class="token punctuation">,</span> Y_train<span class="token punctuation">.</span>shape<span class="token punctuation">,</span> Y_test<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token punctuation">(</span><span class="token number">614</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token number">154</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token number">614</span><span class="token punctuation">,</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token number">154</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="rainbow-模型比较"><a href="#rainbow-模型比较" class="headerlink" title=":rainbow: 模型比较"></a>:rainbow: 模型比较</h4><p>分别使用普通的KNN算法、带权重的KNN算法和指定半径的KNN算法对数据集进行拟合并计算评分：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>neighbors <span class="token keyword">import</span> KNeighborsClassifier<span class="token punctuation">,</span> RadiusNeighborsClassifiermodels <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>models<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"KNN"</span><span class="token punctuation">,</span> KNeighborsClassifier<span class="token punctuation">(</span>n_neighbors<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>models<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"KNN with weights"</span><span class="token punctuation">,</span> KNeighborsClassifier<span class="token punctuation">(</span>    n_neighbors<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> weights<span class="token operator">=</span><span class="token string">"distance"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>models<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"Radius Neighbors"</span><span class="token punctuation">,</span> RadiusNeighborsClassifier<span class="token punctuation">(</span>    n_neighbors<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> radius<span class="token operator">=</span><span class="token number">500.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>results <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> name<span class="token punctuation">,</span> model <span class="token keyword">in</span> models<span class="token punctuation">:</span>    model<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span> Y_train<span class="token punctuation">)</span>    results<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> model<span class="token punctuation">.</span>score<span class="token punctuation">(</span>X_test<span class="token punctuation">,</span> Y_test<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>results<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"name: {}; score: {}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>results<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>results<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>三种算法的性能如下：</p><pre class="line-numbers language-python"><code class="language-python">name<span class="token punctuation">:</span> KNN<span class="token punctuation">;</span> score<span class="token punctuation">:</span> <span class="token number">0.7467532467532467</span>name<span class="token punctuation">:</span> KNN <span class="token keyword">with</span> weights<span class="token punctuation">;</span> score<span class="token punctuation">:</span> <span class="token number">0.6818181818181818</span>name<span class="token punctuation">:</span> Radius Neighbors<span class="token punctuation">;</span> score<span class="token punctuation">:</span> <span class="token number">0.6558441558441559</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>带权重的KNN算法，我们选择了距离越近、权重越高。指定半径的KNN算法的半径选择了500。从上面的输出结果可以看出，普通的KNN算法性能最好。问题来了，这个判断准确么？答案是不准确。因为我们的训练样本和测试样本是随机分配的，不同的训练样本和测试样本组合可能导致计算出来的算法准确性是有差异的。我们可以试着多次运行上面的代码，观察输出值是否有变化。</p><p>怎么样更准确地对比算法准确性呢？一个方法是，多次随机分配训练数据集和交叉验证数据集，然后求模型准确性评分的平均值。所幸，我们不需要从头实现这个过程，<code>scikit-learn</code> 提供了 <code>KFold</code> 和 <code>cross_val_score()</code>函数来处理这种问题：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> KFold<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> cross_val_scoreresults <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> name<span class="token punctuation">,</span> model <span class="token keyword">in</span> models<span class="token punctuation">:</span>    kfold <span class="token operator">=</span> KFold<span class="token punctuation">(</span>n_splits<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span>    cv_result <span class="token operator">=</span> cross_val_score<span class="token punctuation">(</span>model<span class="token punctuation">,</span> X<span class="token punctuation">,</span> Y<span class="token punctuation">,</span> cv<span class="token operator">=</span>kfold<span class="token punctuation">)</span>    results<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> cv_result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>results<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"name: {}; cross val score: {}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>        results<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>results<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码中，我们通过KFold把数据集分成10份，其中1份会作为交叉验证数据集来计算模型准确性，剩余的9份作为训练数据集。cross_val_score()函数总共计算出10次不同训练数据集和交叉验证数据集组合得到的模型准确性评分，最后求平均值。这样的评价结果相对更准确一些。<br> 输出结果为：</p><pre class="line-numbers language-python"><code class="language-python">name<span class="token punctuation">:</span> KNN<span class="token punctuation">;</span> cross val score<span class="token punctuation">:</span> <span class="token number">0.7147641831852358</span>name<span class="token punctuation">:</span> KNN <span class="token keyword">with</span> weights<span class="token punctuation">;</span> cross val score<span class="token punctuation">:</span> <span class="token number">0.6770505809979495</span>name<span class="token punctuation">:</span> Radius Neighbors<span class="token punctuation">;</span> cross val score<span class="token punctuation">:</span> <span class="token number">0.6497265892002735</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="rainbow-模型训练及分析"><a href="#rainbow-模型训练及分析" class="headerlink" title=":rainbow:模型训练及分析"></a>:rainbow:模型训练及分析</h4><p>通过上面的对比来看，普通的KNN算法性能更优一些。接下来，我们就使用普通的KNN算法模型对数据集进行训练，并查看对训练样本的拟合情况以及对测试样本的预测准确性情况：</p><pre class="line-numbers language-python"><code class="language-python">knn <span class="token operator">=</span> KNeighborsClassifier<span class="token punctuation">(</span>n_neighbors<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>knn<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span> Y_train<span class="token punctuation">)</span>train_score <span class="token operator">=</span> knn<span class="token punctuation">.</span>score<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span> Y_train<span class="token punctuation">)</span>test_score <span class="token operator">=</span> knn<span class="token punctuation">.</span>score<span class="token punctuation">(</span>X_test<span class="token punctuation">,</span> Y_test<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"train score: {}\ntest score: {}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>train_score<span class="token punctuation">,</span> test_score<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为：</p><pre class="line-numbers language-python"><code class="language-python">train score<span class="token punctuation">:</span> <span class="token number">0.8387622149837134</span>test score<span class="token punctuation">:</span> <span class="token number">0.7337662337662337</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>从输出中可以看到两个问题。一是对训练样本的拟合情况不佳，评分才0.82多，这说明算法模型太简单了，无法很好地拟合训练样本。二是模型的准确性欠佳，不到74%的预测准确性。我们可以进一步画出学习曲线，证实结论。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> ShuffleSplit<span class="token keyword">from</span> common<span class="token punctuation">.</span>utils <span class="token keyword">import</span> plot_learning_curveknn <span class="token operator">=</span> KNeighborsClassifier<span class="token punctuation">(</span>n_neighbors<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>cv <span class="token operator">=</span> ShuffleSplit<span class="token punctuation">(</span>n_splits<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span> test_size<span class="token operator">=</span><span class="token number">0.2</span><span class="token punctuation">,</span> random_state<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>plot_learning_curve<span class="token punctuation">(</span>plt<span class="token punctuation">,</span> knn<span class="token punctuation">,</span> <span class="token string">"Learn Curve for KNN Diabetes"</span><span class="token punctuation">,</span>                     X<span class="token punctuation">,</span> Y<span class="token punctuation">,</span> ylim<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.01</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cv<span class="token operator">=</span>cv<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200629101150911.png" style="zoom:67%;"><p>从图中可以看出来，训练样本评分较低，且测试样本与训练样本距离较大，这是典型的欠拟合现象。KNN算法没有更好的措施来解决欠拟合问题，我们学完本书的其他章节后，可以试着用其他算法（如逻辑回归算法、支持向量机等）来对比不同模型的准确性情况。</p><h4 id="rainbow-特征选择及数据可视化"><a href="#rainbow-特征选择及数据可视化" class="headerlink" title=":rainbow:特征选择及数据可视化"></a>:rainbow:特征选择及数据可视化</h4><p>那有没有直观的方法，来揭示出为什么KNN算法不是针对这一问题的好模型？一个办法是把数据画出来，可是我们有8个特征，无法在这么高的维度里画出数据，并直观地观察。一个解决办法是特征选择，即只选择2个与输出值相关性最大的特征，这样就可以在二维平面上画出输入特征值与输出值的关系了。</p><p><code>scikit-learn</code>在 <code>sklearn.feature_selection</code> 包里提供了丰富的特征选择方法。我们使用 <code>SelectKBest</code> 来选择相关性最大的两个特征：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>feature_selection <span class="token keyword">import</span> SelectKBestselector <span class="token operator">=</span> SelectKBest<span class="token punctuation">(</span>k<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>X_new <span class="token operator">=</span> selector<span class="token punctuation">.</span>fit_transform<span class="token punctuation">(</span>X<span class="token punctuation">,</span> Y<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'X_new.shape {}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>X_new<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>把相关性最大的两个特征放在X_new变量里，输出结果为：</p><pre class="line-numbers language-python"><code class="language-python">X_new<span class="token punctuation">.</span>shape <span class="token punctuation">(</span><span class="token number">768</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们可能会好奇，相关性最大的特征到底是哪两个？对比一下本节开头的数据即可知道，它们分别是Glucose（血糖浓度）和BMI（身体质量指数）。血糖浓度和糖尿病的关系自不必说，身体质量指数是反映肥胖程度的指标，从业务角度来看，我们选择出来的2个相关性最高的特征还算合理。那么 <code>SelectKBest</code> 到底使用什么神奇的方法选择出了这两个相关性最高的特征呢？详情参考下一节。</p><p>我们来看看，如果只使用这2个相关性最高的特征的话，3种不同的KNN算法哪个准确性更高：</p><pre class="line-numbers language-python"><code class="language-python">results <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> name<span class="token punctuation">,</span> model <span class="token keyword">in</span> models<span class="token punctuation">:</span>    kfold <span class="token operator">=</span> KFold<span class="token punctuation">(</span>n_splits<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span>    cv_result <span class="token operator">=</span> cross_val_score<span class="token punctuation">(</span>model<span class="token punctuation">,</span> X_new<span class="token punctuation">,</span> Y<span class="token punctuation">,</span> cv<span class="token operator">=</span>kfold<span class="token punctuation">)</span>    results<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> cv_result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>results<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"name: {}; cross val score: {}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>        results<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>results<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这次使用X_new作为输入，输出如下</p><pre class="line-numbers language-python"><code class="language-python">name<span class="token punctuation">:</span> KNN<span class="token punctuation">;</span> cross val score<span class="token punctuation">:</span> <span class="token number">0.725205058099795</span>name<span class="token punctuation">:</span> KNN <span class="token keyword">with</span> weights<span class="token punctuation">;</span> cross val score<span class="token punctuation">:</span> <span class="token number">0.6900375939849623</span>name<span class="token punctuation">:</span> Radius Neighbors<span class="token punctuation">;</span> cross val score<span class="token punctuation">:</span> <span class="token number">0.6510252904989747</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>从输出可以看出来，还是普通的KNN模型准确性较高，其准确性也达到了将近 73 %，与所有特征拿来一块儿训练的准确性差不多。这也侧面证明了 <code>SelectKBest</code> 特征选择的有效性。</p><p>回到目标上来，我们是想看看为什么KNN无法很好地拟合训练样本。现在我们只有 2 个特征，可以很方便地在二维坐标上画出所有的训练样本，观察这些数据的分布情况：</p><pre class="line-numbers language-python"><code class="language-python">plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">"BMI"</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">"Glucose"</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>X_new<span class="token punctuation">[</span>Y<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> X_new<span class="token punctuation">[</span>Y<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> c<span class="token operator">=</span><span class="token string">'r'</span><span class="token punctuation">,</span> s<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">,</span> marker<span class="token operator">=</span><span class="token string">'o'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">#画出样本</span>plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>X_new<span class="token punctuation">[</span>Y<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> X_new<span class="token punctuation">[</span>Y<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> c<span class="token operator">=</span><span class="token string">'g'</span><span class="token punctuation">,</span> s<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">,</span> marker<span class="token operator">=</span><span class="token string">'^'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">#画出样本</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200629102028938.png" style="zoom:67%;"><p>横坐标是血糖值 Glucose，纵坐标是BMI值，反映身体肥胖情况。从图中可以看出，在中间数据集密集的区域，阳性样本和阴性样本几乎重叠在一起了。假设现在有一个待预测的样本在中间密集区域，它的阳性邻居多还是阴性邻居多呢？这真的很难说。这样就可以直观地看到，KNN算法在这个糖尿病预测问题上，无法达到很高的预测准确性。</p><h3 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><p>这里再继续再介绍一下特征选择时，计算相关性大小的 <code>SelectKBest()</code> 函数背后的统计学知识。</p><h4 id="如何提高KNN算法的运算效率"><a href="#如何提高KNN算法的运算效率" class="headerlink" title="如何提高KNN算法的运算效率"></a>如何提高KNN算法的运算效率</h4><p>根据算法原理，每次需要预测一个点时，我们都需要计算训练数据集里每个点到这个点的距离，然后选出距离最近的k个点进行投票。当数据集很大时，这个计算成本非常高。针对$N$个样本，$D$个特征的数据集，其算法复杂度为$O(DN^2)$。</p><p>为了解决这个问题，一种叫<code>K-D Tree</code> 的数据结构被发明出来。为了避免每次都重新计算一遍距离，算法会把距离信息保存在一棵树里，这样在计算之前从树里查询距离信息，尽量避免重新计算。其基本原理是，如果A和B距离很远，B和C距离很近，那么A和C的距离也很远。有了这个信息，就可以在合适的时候跳过距离远的点。这样优化后的算法复杂度可降低到$O(DNlog(N))$。感兴趣的读者可参阅论文：Bentley, J.L., Communications of the ACM (1975)。</p><p>1989年，另外一种称为<code>Ball Tree</code>的算法，在<code>K-D Tree</code>的基础上对性能进一步进行了优化。感兴趣的读者可以搜索Five balltree construction algorithms来了解详细的算法信息。</p><h4 id="相关性测试"><a href="#相关性测试" class="headerlink" title="相关性测试"></a>相关性测试</h4><p>先通过一个简单的例子来看假设检验问题，即判断假设的结论是否成立或成立的概率有多高。假设，在一个城市随机采样到程序员和性别的关系的数据：</p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/17634123-0c82f9f4005936fa.png" style="zoom:50%;"><p>假设，我们的结论是程序员和性别无关，这个假设称为原假设（null hypothesis）。问：通过我们随机采样观测到的数据，原假设是否成立，或者说原假设成立的概率有多高？</p><p><code>卡方检验（chi-squared test）</code>是检测假设成立与否的一个常用的工具。它的计算公式是：</p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/17634123-3a52b648ce9e2196.png" style="zoom:50%;"><p>其中，卡方检验的值记为 ,  $O$ 是观测值，$E$  是期望值。针对我们的例子，如果原假设成立，即程序员职业和性别无关，那么我们期望的男程序员数量应该为(14/489) * 242=6.928，女程序员数量应该为(14/489) * 247=7.072，同理可得到我们的期望值如下：</p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/17634123-9f2c88dc6a7eeb66.png" style="zoom:50%;"><p> 根据卡方检验的公式，可以算出卡方值为：</p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/17634123-bf0dbd2fd6c8db0c.png" style="zoom:50%;"><p> 算出卡方值后，怎么判断原假设成立的概率是多少呢？这里还涉及到自由度和卡方分布的概念。简单地讲，自由度是$(r-1)×(c-1)$，其中 r 是行数，c 是列数，针对我们的问题，其自由度为1。卡方分布是指，若n个相互独立的随机变量均服从正态分布，则这 n 个随机变量的平方和构成一新的随机变量，其分布规律称为卡方分布。卡方分布的密度函数和自由度相关，知道了自由度和目标概率，我们就能求出卡方值。</p><p>针对我们的问题，可以查表得到，自由度为1的卡方分布，在99%处的卡方值为6.63。我们计算出来的卡方值为7.670。由于7.67&gt;6.63，故有99%的把握可以推翻原假设。换个说法，如果原假设成立，即程序员职业和性别无关，那么我们随机采样到的数据出现的概率将低于1%。我们可以搜索<code>“卡方表”</code>或<code>“Chi Squared Table”</code>找到不同自由度对应的卡方值。</p><p>卡方值的大小可以反映变量与目标值的相关性，值越大，相关性越大。利用这一特性，<code>SelectKBest()</code> 函数就可以计算不同特征的卡方值来判断特征与输出值的相关性大小，从而完成特征选择。在<code>scikit-learn</code>里，计算卡方值的函数是 <code>sklearn.feature_selection.chi2()</code>。除了卡方检验外，还有<code>F值检验</code>等算法，也可以用来评估特征与目标值的相关性。<code>SelectKBest</code> 默认使用的就是F值检验算法，在<code>scikit-learn</code>里，使用<code>sklearn.feature_selection.f_classif</code>来计算F值。关于F值相关的资料，感兴趣的读者可以在英文版维基百科上搜索<code>“Fisher’sexact test”</code>，了解更多信息。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> ML算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scikit-learn系列一：机器学习基础</title>
      <link href="/2020/06/28/scikit-learn-xi-lie-yi-ji-qi-xue-xi-ji-chu/"/>
      <url>/2020/06/28/scikit-learn-xi-lie-yi-ji-qi-xue-xi-ji-chu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载自作者: 片刻1998<br>GitHub地址:  <a href="https://github.com/apachecn/AiLearning" target="_blank" rel="noopener">https://github.com/apachecn/AiLearning</a></p></blockquote><h2 id="机器学习-概述"><a href="#机器学习-概述" class="headerlink" title="机器学习 概述"></a>机器学习 概述</h2><p><code>机器学习(Machine Learning,ML)</code> 是使用计算机来彰显数据背后的真实含义，它为了把无序的数据转换成有用的信息。是一门多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、算法复杂度理论等多门学科。专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身的性能。<br>它是人工智能的核心，是使计算机具有智能的根本途径，其应用遍及人工智能的各个领域，它主要使用归纳、综合而不是演绎。</p><ol><li>海量的数据</li><li>获取有用的信息</li></ol><h2 id="机器学习-研究意义"><a href="#机器学习-研究意义" class="headerlink" title="机器学习 研究意义"></a>机器学习 研究意义</h2><p>机器学习是一门人工智能的科学，该领域的主要研究对象是人工智能，特别是如何在经验学习中改善具体算法的性能”。 “机器学习是对能通过经验自动改进的计算机算法的研究”。 “机器学习是用数据或以往的经验，以此优化计算机程序的性能标准。” 一种经常引用的英文定义是: A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E.</p><p>机器学习已经有了十分广泛的应用，例如: 数据挖掘、计算机视觉、自然语言处理、生物特征识别、搜索引擎、医学诊断、检测信用卡欺诈、证券市场分析、DNA序列测序、语音和手写识别、战略游戏和机器人运用。</p><h2 id="机器学习-场景"><a href="#机器学习-场景" class="headerlink" title="机器学习 场景"></a>机器学习 场景</h2><ul><li><p>例如: 识别动物猫</p><ul><li>模式识别（官方标准）: 人们通过大量的经验，得到结论，从而判断它就是猫。</li><li>机器学习（数据学习）: 人们通过阅读进行学习，观察它会叫、小眼睛、两只耳朵、四条腿、一条尾巴，得到结论，从而判断它就是猫。</li><li>深度学习（深入数据）: 人们通过深入了解它，发现它会’喵喵’的叫、与同类的猫科动物很类似，得到结论，从而判断它就是猫。（深度学习常用领域: 语音识别、图像识别）</li></ul></li><li><p>模式识别（pattern recognition）: 模式识别是最古老的（作为一个术语而言，可以说是很过时的）。</p><ul><li>我们把环境与客体统称为“模式”，识别是对模式的一种认知，是如何让一个计算机程序去做一些看起来很“智能”的事情。</li><li>通过融于智慧和直觉后，通过构建程序，识别一些事物，而不是人，例如: 识别数字。</li></ul></li><li><p>机器学习（machine learning）: 机器学习是最基础的（当下初创公司和研究实验室的热点领域之一）。</p><ul><li>在90年代初，人们开始意识到一种可以更有效地构建模式识别算法的方法，那就是用数据（可以通过廉价劳动力采集获得）去替换专家（具有很多图像方面知识的人）。</li><li>“机器学习”强调的是，在给计算机程序（或者机器）输入一些数据后，它必须做一些事情，那就是学习这些数据，而这个学习的步骤是明确的。</li><li>机器学习（Machine Learning）是一门专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身性能的学科。</li></ul></li><li><p>深度学习（deep learning）: 深度学习是非常崭新和有影响力的前沿领域，我们甚至不会去思考-后深度学习时代。</p><ul><li>深度学习是机器学习研究中的一个新的领域，其动机在于建立、模拟人脑进行分析学习的神经网络，它模仿人脑的机制来解释数据，例如图像，声音和文本。</li></ul></li><li><p>参考地址:  </p><ul><li><a href="http://www.csdn.net/article/2015-03-24/2824301" target="_blank" rel="noopener">深度学习 vs 机器学习 vs 模式识别</a></li><li><a href="http://baike.baidu.com/link?url=76P-uA4EBrC3G-I__P1tqeO7eoDS709Kp4wYuHxc7GNkz_xn0NxuAtEohbpey7LUa2zUQLJxvIKUx4bnrEfOmsWLKbDmvG1PCoRkJisMTQka6-QReTrIxdYY3v93f55q" target="_blank" rel="noopener">深度学习 百科资料</a></li></ul></li></ul><blockquote><p>机器学习已应用于多个领域，远远超出大多数人的想象，横跨: 计算机科学、工程技术和统计学等多个学科。</p></blockquote><ul><li>搜索引擎: 根据你的搜索点击，优化你下次的搜索结果,是机器学习来帮助搜索引擎判断哪个结果更适合你（也判断哪个广告更适合你）。</li><li>垃圾邮件: 会自动的过滤垃圾广告邮件到垃圾箱内。</li><li>超市优惠券: 你会发现，你在购买小孩子尿布的时候，售货员会赠送你一张优惠券可以兑换6罐啤酒。</li><li>邮局邮寄: 手写软件自动识别寄送贺卡的地址。</li><li>申请贷款: 通过你最近的金融活动信息进行综合评定，决定你是否合格。</li></ul><h2 id="机器学习-组成"><a href="#机器学习-组成" class="headerlink" title="机器学习 组成"></a>机器学习 组成</h2><h3 id="主要任务"><a href="#主要任务" class="headerlink" title="主要任务"></a>主要任务</h3><ul><li>分类（classification）: 将实例数据划分到合适的类别中。<ul><li>应用实例: 判断网站是否被黑客入侵（二分类 ），手写数字的自动识别（多分类）</li></ul></li><li>回归（regression）: 主要用于预测数值型数据。<ul><li>应用实例: 股票价格波动的预测，房屋价格的预测等。</li></ul></li></ul><h3 id="监督学习（supervised-learning）"><a href="#监督学习（supervised-learning）" class="headerlink" title="监督学习（supervised learning）"></a>监督学习（supervised learning）</h3><ul><li>必须确定目标变量的值，以便机器学习算法可以发现特征和目标变量之间的关系。在监督学习中，给定一组数据，我们知道正确的输出结果应该是什么样子，并且知道在输入和输出之间有着一个特定的关系。 (包括: 分类和回归)</li><li>样本集: 训练数据 + 测试数据<ul><li>训练样本 = 特征(feature) + 目标变量(label: 分类-离散值/回归-连续值)</li><li>特征通常是训练样本集的列，它们是独立测量得到的。</li><li>目标变量: 目标变量是机器学习预测算法的测试结果。<ul><li>在分类算法中目标变量的类型通常是标称型(如: 真与假)，而在回归算法中通常是连续型(如: 1~100)。</li></ul></li></ul></li><li>监督学习需要注意的问题: <ul><li>偏置方差权衡</li><li>功能的复杂性和数量的训练数据</li><li>输入空间的维数</li><li>噪声中的输出值</li></ul></li><li><code>知识表示</code>: <ul><li>可以采用规则集的形式【例如: 数学成绩大于90分为优秀】</li><li>可以采用概率分布的形式【例如: 通过统计分布发现，90%的同学数学成绩，在70分以下，那么大于70分定为优秀】</li><li>可以使用训练样本集中的一个实例【例如: 通过样本集合，我们训练出一个模型实例，得出 年轻，数学成绩中高等，谈吐优雅，我们认为是优秀】</li></ul></li></ul><h3 id="非监督学习（unsupervised-learning）"><a href="#非监督学习（unsupervised-learning）" class="headerlink" title="非监督学习（unsupervised learning）"></a>非监督学习（unsupervised learning）</h3><ul><li>在机器学习，无监督学习的问题是，在未加标签的数据中，试图找到隐藏的结构。因为提供给学习者的实例是未标记的，因此没有错误或报酬信号来评估潜在的解决方案。</li><li>无监督学习是密切相关的统计数据密度估计的问题。然而无监督学习还包括寻求，总结和解释数据的主要特点等诸多技术。在无监督学习使用的许多方法是基于用于处理数据的数据挖掘方法。</li><li>数据没有类别信息，也不会给定目标值。</li><li>非监督学习包括的类型: <ul><li>聚类: 在无监督学习中，将数据集分成由类似的对象组成多个类的过程称为聚类。</li><li>密度估计: 通过样本分布的紧密程度，来估计与分组的相似性。</li><li>此外，无监督学习还可以减少数据特征的维度，以便我们可以使用二维或三维图形更加直观地展示数据信息。</li></ul></li></ul><h3 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h3><p>这个算法可以训练程序做出某一决定。程序在某一情况下尝试所有的可能行动，记录不同行动的结果并试着找出最好的一次尝试来做决定。 属于这一类算法的有马尔可夫决策过程。</p><h3 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h3><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E8%AE%AD%E7%BB%83%E8%BF%87%E7%A8%8B.jpg" alt="机器学习训练过程图"></p><h3 id="算法汇总"><a href="#算法汇总" class="headerlink" title="算法汇总"></a>算法汇总</h3><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/ml_algorithm.jpg" alt="算法汇总"></p><h2 id="机器学习-使用"><a href="#机器学习-使用" class="headerlink" title="机器学习 使用"></a>机器学习 使用</h2><blockquote><p>选择算法需要考虑的两个问题</p></blockquote><ol><li>算法场景<ul><li>预测明天是否下雨，因为可以用历史的天气情况做预测，所以选择监督学习算法</li><li>给一群陌生的人进行分组，但是我们并没有这些人的类别信息，所以选择无监督学习算法、通过他们身高、体重等特征进行处理。</li></ul></li><li>需要收集或分析的数据是什么</li></ol><blockquote><p>举例</p></blockquote><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80-%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95.jpg" alt="选择算法图"></p><blockquote><p>机器学习 开发流程</p></blockquote><ol><li>收集数据: 收集样本数据</li><li>准备数据: 注意数据的格式</li><li>分析数据: 为了确保数据集中没有垃圾数据；<ul><li>如果是算法可以处理的数据格式或可信任的数据源，则可以跳过该步骤；</li><li>另外该步骤需要人工干预，会降低自动化系统的价值。</li></ul></li><li>训练算法: [机器学习算法核心]如果使用无监督学习算法，由于不存在目标变量值，则可以跳过该步骤</li><li>测试算法: [机器学习算法核心]评估算法效果</li><li>使用算法: 将机器学习算法转为应用程序</li></ol><h2 id="机器学习-数学基础"><a href="#机器学习-数学基础" class="headerlink" title="机器学习 数学基础"></a>机器学习 数学基础</h2><ul><li>微积分</li><li>统计学/概率论</li><li>线性代数</li></ul><h2 id="机器学习-工具"><a href="#机器学习-工具" class="headerlink" title="机器学习 工具"></a>机器学习 工具</h2><h3 id="Python语言"><a href="#Python语言" class="headerlink" title="Python语言"></a>Python语言</h3><ol><li>可执行伪代码</li><li>Python比较流行: 使用广泛、代码范例多、丰富模块库，开发周期短</li><li>Python语言的特色: 清晰简练、易于理解</li><li>Python语言的缺点: 唯一不足的是性能问题</li><li>Python相关的库<ul><li>科学函数库: <code>SciPy</code>、<code>NumPy</code>(底层语言: C和Fortran)</li><li>绘图工具库: <code>Matplotlib</code></li><li>数据分析库 <code>Pandas</code></li></ul></li></ol><h3 id="数学工具"><a href="#数学工具" class="headerlink" title="数学工具"></a>数学工具</h3><ul><li>Matlab</li></ul><h2 id="附-机器学习专业术语"><a href="#附-机器学习专业术语" class="headerlink" title="附: 机器学习专业术语"></a>附: 机器学习专业术语</h2><ul><li>模型（model）: 计算机层面的认知</li><li>学习算法（learning algorithm），从数据中产生模型的方法</li><li>数据集（data set）: 一组记录的合集</li><li>示例（instance）: 对于某个对象的描述</li><li>样本（sample）: 也叫示例</li><li>属性（attribute）: 对象的某方面表现或特征</li><li>特征（feature）: 同属性</li><li>属性值（attribute value）: 属性上的取值</li><li>属性空间（attribute space）: 属性张成的空间</li><li>样本空间/输入空间（samplespace）: 同属性空间</li><li>特征向量（feature vector）: 在属性空间里每个点对应一个坐标向量，把一个示例称作特征向量</li><li>维数（dimensionality）: 描述样本参数的个数（也就是空间是几维的）</li><li>学习（learning）/训练（training）: 从数据中学得模型</li><li>训练数据（training data）: 训练过程中用到的数据</li><li>训练样本（training sample）:训练用到的每个样本</li><li>训练集（training set）: 训练样本组成的集合</li><li>假设（hypothesis）: 学习模型对应了关于数据的某种潜在规则</li><li>真相（ground-truth）:真正存在的潜在规律</li><li>学习器（learner）: 模型的另一种叫法，把学习算法在给定数据和参数空间的实例化</li><li>预测（prediction）: 判断一个东西的属性</li><li>标记（label）: 关于示例的结果信息，比如我是一个“好人”。</li><li>样例（example）: 拥有标记的示例</li><li>标记空间/输出空间（label space）: 所有标记的集合</li><li>分类（classification）: 预测是离散值，比如把人分为好人和坏人之类的学习任务</li><li>回归（regression）: 预测值是连续值，比如你的好人程度达到了0.9，0.6之类的</li><li>二分类（binary classification）: 只涉及两个类别的分类任务</li><li>正类（positive class）: 二分类里的一个</li><li>反类（negative class）: 二分类里的另外一个</li><li>多分类（multi-class classification）: 涉及多个类别的分类</li><li>测试（testing）: 学习到模型之后对样本进行预测的过程</li><li>测试样本（testing sample）: 被预测的样本</li><li>聚类（clustering）: 把训练集中的对象分为若干组</li><li>簇（cluster）: 每一个组叫簇</li><li>监督学习（supervised learning）: 典范–分类和回归</li><li>无监督学习（unsupervised learning）: 典范–聚类</li><li>未见示例（unseen instance）: “新样本“，没训练过的样本</li><li>泛化（generalization）能力: 学得的模型适用于新样本的能力</li><li>分布（distribution）: 样本空间的全体样本服从的一种规律</li><li>独立同分布（independent and identically distributed，简称i,i,d.）:获得的每个样本都是独立地从这个分布上采样获得的。</li></ul><h2 id="机器学习基础补充"><a href="#机器学习基础补充" class="headerlink" title="机器学习基础补充"></a>机器学习基础补充</h2><h3 id="数据集的划分"><a href="#数据集的划分" class="headerlink" title="数据集的划分"></a>数据集的划分</h3><ul><li>训练集（Training set） —— 学习样本数据集，通过匹配一些参数来建立一个模型，主要用来训练模型。类比考研前做的解题大全。</li><li>验证集（validation set） —— 对学习出来的模型，调整模型的参数，如在神经网络中选择隐藏单元数。验证集还用来确定网络结构或者控制模型复杂程度的参数。类比 考研之前做的模拟考试。</li><li>测试集（Test set） —— 测试训练好的模型的分辨能力。类比 考研。这次真的是一考定终身。</li></ul><h3 id="模型拟合程度"><a href="#模型拟合程度" class="headerlink" title="模型拟合程度"></a>模型拟合程度</h3><ul><li>欠拟合（Underfitting）: 模型没有很好地捕捉到数据特征，不能够很好地拟合数据，对训练样本的一般性质尚未学好。类比，光看书不做题觉得自己什么都会了，上了考场才知道自己啥都不会。</li><li>过拟合（Overfitting）: 模型把训练样本学习“太好了”，可能把一些训练样本自身的特性当做了所有潜在样本都有的一般性质，导致泛化能力下降。类比，做课后题全都做对了，超纲题也都认为是考试必考题目，上了考场还是啥都不会。 </li></ul><p>通俗来说，欠拟合和过拟合都可以用一句话来说，欠拟合就是: “你太天真了！”，过拟合就是: “你想太多了！”。</p><h3 id="常见的模型指标"><a href="#常见的模型指标" class="headerlink" title="常见的模型指标"></a>常见的模型指标</h3><ul><li>正确率 —— 提取出的正确信息条数 / 提取出的信息条数</li><li>召回率 —— 提取出的正确信息条数 / 样本中的信息条数</li><li>F 值 —— 正确率 * 召回率 * 2 / （正确率 + 召回率）（F值即为正确率和召回率的调和平均值）</li></ul><p>举个例子如下: </p><p>举个例子如下:<br>某池塘有 1400 条鲤鱼，300 只虾，300 只乌龟。现在以捕鲤鱼为目的。撒了一张网，逮住了 700 条鲤鱼，200 只<br>虾， 100 只乌龟。那么这些指标分别如下:<br>正确率 = 700 / (700 + 200 + 100) = 70%<br>召回率 = 700 / 1400 = 50%<br>F 值 = 70% * 50% * 2 / (70% + 50%) = 58.3%</p><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><ul><li>分类问题 —— 说白了就是将一些未知类别的数据分到现在已知的类别中去。比如，根据你的一些信息，判断你是高富帅，还是穷屌丝。评判分类效果好坏的三个指标就是上面介绍的三个指标: 正确率，召回率，F值。</li><li>回归问题 —— 对数值型连续随机变量进行预测和建模的监督学习算法。回归往往会通过计算 误差（Error）来确定模型的精确性。</li><li>聚类问题 —— 聚类是一种无监督学习任务，该算法基于数据的内部结构寻找观察样本的自然族群（即集群）。聚类问题的标准一般基于距离: 簇内距离（Intra-cluster Distance） 和 簇间距离（Inter-cluster Distance） 。簇内距离是越小越好，也就是簇内的元素越相似越好；而簇间距离越大越好，也就是说簇间（不同簇）元素越不相同越好。一般的，衡量聚类问题会给出一个结合簇内距离和簇间距离的公式。</li></ul><p>下面这个图可以比较直观地展示出来: </p><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/ml_add_2.jpg" alt=""></p><h3 id="特征工程的一些小东西"><a href="#特征工程的一些小东西" class="headerlink" title="特征工程的一些小东西"></a>特征工程的一些小东西</h3><ul><li><p>特征选择 —— 也叫特征子集选择（FSS，Feature Subset Selection）。是指从已有的 M 个特征（Feature）中选择 N 个特征使得系统的特定指标最优化，是从原始特征中选择出一些最有效特征以降低数据集维度的过程，是提高算法性能的一个重要手段，也是模式识别中关键的数据预处理步骤。</p></li><li><p>特征提取 —— 特征提取是计算机视觉和图像处理中的一个概念。它指的是使用计算机提取图像信息，决定每个图像的点是否属于一个图像特征。特征提取的结果是把图像上的点分为不同的子集，这些子集往往属于孤立的点，连续的曲线或者连续的区域。</p></li></ul><p>下面给出一个特征工程的图: </p><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/ml_add_1.jpg" alt=""></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><p>Learning rate —— 学习率，通俗地理解，可以理解为步长，步子大了，很容易错过最佳结果。就是本来目标尽在咫尺，可是因为我迈的步子很大，却一下子走过了。步子小了呢，就是同样的距离，我却要走很多很多步，这样导致训练的耗时费力还不讨好。</p></li><li><p>机器学习的数学基础 : <a href="https://zhuanlan.zhihu.com/p/25197792" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25197792</a></p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客备份</title>
      <link href="/2020/06/28/hexo-bo-ke-bei-fen/"/>
      <url>/2020/06/28/hexo-bo-ke-bei-fen/</url>
      
        <content type="html"><![CDATA[<p><a href="https://dongzhougu.github.io/2020/06/27/shi-yong-hexo-da-jian-github-bo-ke/">上一篇文章</a>已经具体讲述了博客的搭建与基本使用，接下来记录博客的备份工作。</p><h4 id="初始备份"><a href="#初始备份" class="headerlink" title="初始备份"></a>初始备份</h4><ul><li><p>创建一个仓库用来存放备份文件，我的名字选择 <strong><a href="https://github.com/DongZhouGu/Blog-backup" target="_blank" rel="noopener">Blog-backup</a></strong>，勾选README。</p></li><li><p>复制仓库地址，运行Git将仓库clone到本地。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> clone git@github.com:DongZhouGu/Blog-backup.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>将要备份的文件放到我们刚才clone的文件夹里面。</p></li><li><p>在 clone 的文件夹下运行 Git，依次输入以下命令：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> add <span class="token keyword">.</span><span class="token function">git</span> commit  -m  <span class="token string">"博客备份"</span>  （注：“backup”里面换成你需要，如“first commit”）<span class="token function">git</span> push -u origin master   （注：此操作目的是把本地仓库push到github上面，如果没有使用密钥此步骤需要你输入帐号和密码）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="更新备份"><a href="#更新备份" class="headerlink" title="更新备份"></a>更新备份</h4><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> add <span class="token keyword">.</span><span class="token function">git</span> commit  -m  <span class="token string">"博客备份"</span><span class="token function">git</span> push origin master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客优化加速</title>
      <link href="/2020/06/27/hexo-bo-ke-you-hua-jia-su/"/>
      <url>/2020/06/27/hexo-bo-ke-you-hua-jia-su/</url>
      
        <content type="html"><![CDATA[<p><a href="https://dongzhougu.github.io/2020/06/27/shi-yong-hexo-da-jian-github-bo-ke/">上一篇文章</a>已经具体讲述了博客的搭建与基本使用，接下来记录一下对博客的优化的工作，从<code>图片加载优化</code>和 <code>PicGo  图床</code>来介绍。</p><h3 id="图片加载优化"><a href="#图片加载优化" class="headerlink" title="图片加载优化"></a>图片加载优化</h3><h4 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h4><blockquote><p><code>预加载</code>就是进入项目前提前加载资源，避免在项目中加载缓慢，影响用户体验</p><p><code>懒加载</code>一般是当图片滚动进可视窗口内才加载图片，可视窗口之外的图片则不加载</p></blockquote><p><a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank" rel="noopener">matery主题</a>  整体采用预加载模式，这样可以在我们访问其他页面的时候会稍微快点。我们可以在这个基础上对图片进行懒加载，这样做效果就是 html、css、js 加载之后，图片再加载。既保证了网页的打开速度，也不会因图片的庞大体积而拖累了整个页面的加载。</p><h4 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h4><ul><li><p>在 Blog 根目录执行</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-lazyload-image --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>在根目录下的 <code>_config.yml</code> 中添加对应配置</p><pre class="line-numbers language-bash"><code class="language-bash">lazyload:  enable: <span class="token boolean">true</span>   onlypost: <span class="token boolean">false</span>  <span class="token comment" spellcheck="true"># 是否只对文章的图片做懒加载</span>  loadingImg: <span class="token comment" spellcheck="true"># eg ./images/loading.gif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="设置插件"><a href="#设置插件" class="headerlink" title="设置插件"></a>设置插件</h4><ul><li><p>修改 <code>/themes/matery/source/js</code> 中的 <code>matery.js</code>文件,在第108行加上：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">$</span><span class="token punctuation">(</span>document<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">'img[data-original]'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">each</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"href"</span><span class="token punctuation">,</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"data-original"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>打开 <code>/themes/matery/layout/_partial/header.ejs</code>文件，</p><p>在<code>img</code>和<code>span</code>的两个头加个<code>div</code>：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>brand-logo<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>&lt;%- url_for() %<span class="token punctuation">></span><span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>waves-effect waves-light<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>            &lt;% if (theme.logo !== undefined &amp;&amp; theme.logo.length > 0) { %>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>&lt;%<span class="token punctuation">=</span> theme.logo %<span class="token punctuation">></span><span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>logo-img<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>LOGO<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>%</span> <span class="token attr-name">}</span> <span class="token attr-name">%</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>logo-span<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>%-</span> <span class="token attr-name">config.title</span> <span class="token attr-name">%</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="自定义loading图片"><a href="#自定义loading图片" class="headerlink" title="自定义loading图片"></a>自定义loading图片</h4><p><code>hexo-lazyload-image</code> 插件提供了自定义loading图片的选项，在 <code>loadingImg</code> 后配置图片的路径即可。</p><h3 id="使用PicGo图床"><a href="#使用PicGo图床" class="headerlink" title="使用PicGo图床"></a>使用PicGo图床</h3><p>PicGo 是一款开源的图床软件，该软件与iPic的不分伯仲，文档支持中文，支持插件开发。</p><h4 id="安装-PicGo"><a href="#安装-PicGo" class="headerlink" title="安装 PicGo"></a>安装 PicGo</h4><p>下载地址 <a href="https://github.com/Molunerfinn/PicGo/releases" target="_blank" rel="noopener">https://github.com/Molunerfinn/PicGo/releases</a> ，选择下载与系统匹配的安装包，正常安装即可。</p><p>下载速度非常慢。。。备用地址：<a href="https://pan.baidu.com/s/1t3wookLIEE4NSXuaGABGPg" target="_blank" rel="noopener">链接</a> 提取码：btzt</p><h4 id="创建GitHub仓库"><a href="#创建GitHub仓库" class="headerlink" title="创建GitHub仓库"></a>创建GitHub仓库</h4><p>创建一个用于存放图片的仓库，之后依次点击 <code>Setting</code> —— <code>Developer settings</code> —— <code>Personal access tokens</code>  创建一个token，并复制下来。</p><h4 id="配置-PicGo"><a href="#配置-PicGo" class="headerlink" title="配置 PicGo"></a>配置 PicGo</h4><p>下载完成后进行安装，安装完毕后开始配置，如图：</p><p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/20200628130208.png" alt=""></p><p><code>设定仓库名</code> 按照“账户名/仓库名的格式填写”，比如我的是：DongZhouGu/imageuse1</p><p><code>分支名</code>统一填写“master”。</p><p><code>设定Token</code>将之前的Token粘贴在这里。</p><p><code>指定存储路径</code>留空。</p><p><code>自定义域名</code>上传图片后成功后，PicGo会将“自定义域名+上传的图片名”生成的访问链接，放到剪切板上。默认留空也可以正常使用。这里为了使用CDN加快图片的访问速度，自定义域名我们按照这样去填写</p><blockquote><p><em><a href="https://cdn.jsdelivr.net/gh/GitHub用户名/仓库名" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/GitHub用户名/仓库名</a></em></p><p>我的是：<a href="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1</a></p></blockquote><p>之后就可以正常使用了</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Hexo搭建Github博客</title>
      <link href="/2020/06/27/shi-yong-hexo-da-jian-github-bo-ke/"/>
      <url>/2020/06/27/shi-yong-hexo-da-jian-github-bo-ke/</url>
      
        <content type="html"><![CDATA[<p>以下为搭建本博客的教程<strong>(针对windows)</strong>，记录一下自己的过程，也方便想要建站的小伙伴快速上手。</p><blockquote><p><code>Github Pages:</code> 可以被认为是用户编写的、托管在 Github 上的静态网页。使用 Github Pages 可以为你提供一个免费的服务器，免去了自己搭建服务器和写数据库的麻烦。此外还可以绑定自己的域名。</p><p><code>Hexo</code>: 一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p></blockquote><p>下面从<strong>搭建前的准备工作</strong>，<strong>Github 部署</strong>，<strong>优化设置博客</strong>(使用  <code>matery</code>  主题)三方面详细介绍。</p><h3 id="1-搭建前的准备工作"><a href="#1-搭建前的准备工作" class="headerlink" title="1. 搭建前的准备工作"></a>1. 搭建前的准备工作</h3><h4 id="1-1-环境安装"><a href="#1-1-环境安装" class="headerlink" title="1.1 环境安装"></a>1.1 环境安装</h4><ul><li><p>安装  <a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a>（点击前往官网），请确保勾选  <strong>Add to PATH</strong>  选项（默认已勾选），这里可以参考 Hexo 的官方<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">参考文档</a>。</p></li><li><p>安装<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git</a>(点击前往官网)，一路默认安装即可。</p></li><li><p>鼠标右键点击  <code>Git Bash Here</code> ,分别使用  <code>node -v</code>  和  <code>npm -v</code>  来验证安装，显示版本号则安装成功。</p></li></ul><h4 id="1-2-Hexo安装"><a href="#1-2-Hexo安装" class="headerlink" title="1.2 Hexo安装"></a>1.2 Hexo安装</h4><ul><li><p>新建一个存放博客的文件夹，比如  <code>E:\notebook\my_blog</code>，在此文件夹下右键点击  <code>Git Bash Here</code></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> -g hexo-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装完成后使用  <code>hexo -v</code>  检测是否安装成功</p></li><li><p>执行初始化并在本地查看效果</p><pre class="line-numbers language-bash"><code class="language-bash">hexo init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>完成后使用</p><pre class="line-numbers language-bash"><code class="language-bash">  hexo s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后会出来一段 http 开头的网址，我们复制下来然后在浏览器打开，就可以看到初始化的 Hexo 的页面了。</p></li></ul><h3 id="2-Github部署"><a href="#2-Github部署" class="headerlink" title="2. Github部署"></a>2. Github部署</h3><ul><li><p><strong>创建一个仓库</strong>，名字必须是  <code>用户名.github.io</code>  ，然后勾选初始化 README。我第一次访问不了就是因为 github 竟然打错了，打错了，打错了…</p></li><li><p><strong>创建一个git秘钥</strong>，用来在这台电脑上通过 git 操作实现本地代码库与 Github 代码库同步</p><pre class="line-numbers language-bash"><code class="language-bash">$ ssh-keygen -t rsa -C “your_email@youremail.com“<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>your_email@youremail.com</code>  为你的 Github 邮箱地址，比如我的是  <code>gdz678@163.com</code></p><p>不管出现什么信息，只需要回车就可以了。接着，运行下面的命令将秘钥复制到剪切板</p><pre class="line-numbers language-bash"><code class="language-bash"> $ clip <span class="token operator">&lt;</span> ~/.ssh/id_rsa.pub<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>在 GitHub 账户中添加秘钥</strong>，进入 Github 的设置，点击  <code>Settings–SSH</code>  ——  <code>New SSH Key</code>，添加刚才复制的秘钥即可。</p></li><li><p><strong>测试</strong>，输入以下命令：注意：<code>git@github.com</code>不要做任何更改！</p><pre class="line-numbers language-bash"><code class="language-bash"> $ <span class="token function">ssh</span> -T git@github.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>根据返回，输入 <code>yes</code> 会显示成功授权</p></li><li><p><strong>配置 Git 个人信息</strong>，Git 会根据用户的名字和邮箱来记录提交，GitHub 也是用这些信息来做权限的处理，输入以下命令进行个人信息的设置，把名称和邮箱替换成你自己的，名字可以不是 GitHub 的昵称，但为了方便记忆，建议与 GitHub 一致。</p><pre class="line-numbers language-bash"><code class="language-bash"> $ <span class="token function">git</span> config --global user.name <span class="token string">"此处填你的用户名"</span>   $ <span class="token function">git</span> config --global user.email  <span class="token string">"此处填你的邮箱"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>将本地的 Hexo 文件更新到 Github 的库中</strong>，登录 Github 打开博客的项目，鼠标移到 <code>Clone or download</code> 按钮，选择 <code>Use SSH</code> 一键复制地址后，打开刚才创建的博客文件夹下的 <code>_config.yaml</code>文件</p><pre class="line-numbers language-bash"><code class="language-bash">deploy:  type: <span class="token function">git</span>  repo: 你复制的地址  branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>部署到 Github</strong>,首先安装  <code>deployer</code> </p><pre><code> npm install hexo-deployer-git --save</code></pre><p>接着执行,博客就部署到 Github 上了</p><pre class="line-numbers language-bash"><code class="language-bash"> $ hexo g -d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后，你的博客地址：https://你的用户名.github.io，比如我的是：<a href="https://dongzhougu.github.io">https://dongzhougu.github.io</a> ,现在每个人都可以通过此链接访问我的博客！</p></li></ul><h3 id="3-优化设置博客"><a href="#3-优化设置博客" class="headerlink" title="3. 优化设置博客"></a>3. 优化设置博客</h3><h4 id="3-1-安装主题"><a href="#3-1-安装主题" class="headerlink" title="3.1 安装主题"></a>3.1 安装主题</h4><ul><li><p>安装 <a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank" rel="noopener">Metary</a> 主题。cd 到 Blog 目录下的 <code>Themes</code> 文件夹</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/blinkfox/hexo-theme-matery.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>编辑站点配置文件 <code>_config.yml</code>,修改主题</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># Extensions</span><span class="token comment" spellcheck="true">## Plugins: https://hexo.io/plugins/</span><span class="token comment" spellcheck="true">## Themes: https://hexo.io/themes/</span>theme: hexo-theme-matery<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><blockquote><p><strong>主题的具体美化和设置可以<a href="http://blinkfox.com/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/#toc-heading-19" target="_blank" rel="noopener">参考这里</a>。</strong></p></blockquote><h4 id="3-2-安装插件"><a href="#3-2-安装插件" class="headerlink" title="3.2 安装插件"></a>3.2 安装插件</h4><p>cd到博客的根目录，分别运行以下，来安装插件</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-feed --save                 <span class="token comment" spellcheck="true">#RSS</span><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-search --save               <span class="token comment" spellcheck="true">#搜索</span><span class="token function">npm</span> <span class="token function">install</span> hexo-prism-plugin --save                   <span class="token comment" spellcheck="true">#代码高亮     </span><span class="token function">npm</span> <span class="token function">install</span> hexo-wordcount --save                      <span class="token comment" spellcheck="true">#文章字数统计</span><span class="token function">npm</span> i hexo-permalink-pinyin --save<span class="token function">npm</span> <span class="token function">install</span> hexo-filter-github-emojis --save           <span class="token comment" spellcheck="true">#添加emoji表情支持</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>RSS</strong> :  在根目录下的 <code>_config.yml</code> 中添加对应配置</p><pre class="line-numbers language-bash"><code class="language-bash">feed:  type: atom  path: atom.xml  limit: 20  hub:  content:  content_limit: 140  content_limit_delim: <span class="token string">' '</span>  order_by: -date<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>搜索</strong> : 在根目录下的 <code>_config.yml</code> 中添加对应配置</p><pre class="line-numbers language-bash"><code class="language-bash">search:  path: search.xml  field: post<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong>代码高亮</strong> ： 修改根目录下 <code>_config.yml</code> 文件中  <code>highlight.enable</code> 的值为 <code>false</code> ，并新增以下配置</p><pre class="line-numbers language-bash"><code class="language-bash">prism_plugin:  mode: <span class="token string">'preprocess'</span>    <span class="token comment" spellcheck="true"># realtime/preprocess</span>  theme: <span class="token string">'tomorrow'</span>  line_number: <span class="token boolean">false</span>    <span class="token comment" spellcheck="true"># default false</span>  custom_css:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>字数统计</strong>：在根目录下的 <code>_config.yml</code> 中添加对应配置</p><pre class="line-numbers language-bash"><code class="language-bash">postInfo:  date: <span class="token boolean">true</span>  update: <span class="token boolean">false</span>  wordCount: <span class="token boolean">false</span>  <span class="token comment" spellcheck="true"># 设置文章字数统计为 true.</span>  totalCount: <span class="token boolean">false</span> <span class="token comment" spellcheck="true"># 设置站点文章总字数统计为 true.</span>  min2read: <span class="token boolean">false</span>   <span class="token comment" spellcheck="true"># 阅读时长.</span>  readCount: <span class="token boolean">false</span>  <span class="token comment" spellcheck="true"># 阅读次数.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>文章链接转静态短地址</strong>：在根目录下的 <code>_config.yml</code> 中添加对应配置</p><pre class="line-numbers language-bash"><code class="language-bash">permalink_pinyin:  enable: <span class="token boolean">true</span>  separator: <span class="token string">'-'</span> <span class="token comment" spellcheck="true"># default: '-'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong>添加emoji表情支持</strong>: 在根目录下的 <code>_config.yml</code> 中添加对应配置</p><pre class="line-numbers language-bash"><code class="language-bash">githubEmojis:  enable: <span class="token boolean">true</span>  className: github-emoji  inject: <span class="token boolean">true</span>  styles:  customEmojis:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ul><li><p><strong>评论系统</strong>： </p><ul><li>评论系统采用的是Valine，基于 <a href="https://www.leancloud.cn/" target="_blank" rel="noopener">leancloud</a>。注册账号后完成认证，创建应用，名称随意，比如 blog，复制应用的 <code>APPID</code> 和 <code>APPKey</code> ，填入主题配置文件中的 Valine 配置中。</li></ul></li><li><p>需要在 <a href="https://www.leancloud.cn/" target="_blank" rel="noopener">leancloud</a> 应用内的“存储”选项中创建<code>class</code>，名称为<code>Comment</code>，否则评论系统无法工作！</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># To use it, activate the configuration item and set appId and appKey.</span><span class="token comment" spellcheck="true"># Valine 评论模块的配置，默认为不激活，如要使用，就请激活该配置项，并设置 appId 和 appKey.</span>valine:  enable: <span class="token boolean">true</span>  appId: *******  appKey: *******  notify: <span class="token boolean">false</span>  verify: <span class="token boolean">false</span>  visitor: <span class="token boolean">true</span>  avatar: <span class="token string">'mm'</span> <span class="token comment" spellcheck="true"># Gravatar style : mm/identicon/monsterid/wavatar/retro/hide</span>  pageSize: 10  placeholder: <span class="token string">'快来交流吧'</span>  background: /medias/comment_bg.png<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="3-3-代码压缩"><a href="#3-3-代码压缩" class="headerlink" title="3.3 代码压缩"></a>3.3 代码压缩</h4><p>使用gulp来压缩网站的资源，包括js,html,css</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 安装gulp</span><span class="token function">npm</span> <span class="token function">install</span> gulp -g            <span class="token comment" spellcheck="true"># 安装组件</span><span class="token function">npm</span> <span class="token function">install</span> gulp-htmlclean gulp-htmlmin gulp-minify-css gulp-uglify gulp-imagemin --save<span class="token comment" spellcheck="true"># 额外的功能模块</span><span class="token function">npm</span> <span class="token function">install</span> gulp-debug gulp-clean-css gulp-changed gulp-if gulp-plumber gulp-babel babel-preset-es2015 del @babel/core --save<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Blog 根目录新建文件 <code>gulpfile.js</code> ，填入以下内容</p><pre class="line-numbers language-bash"><code class="language-bash">var gulp <span class="token operator">=</span> require<span class="token punctuation">(</span><span class="token string">"gulp"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>var debug <span class="token operator">=</span> require<span class="token punctuation">(</span><span class="token string">"gulp-debug"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>var cleancss <span class="token operator">=</span> require<span class="token punctuation">(</span><span class="token string">"gulp-clean-css"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> //css压缩组件var uglify <span class="token operator">=</span> require<span class="token punctuation">(</span><span class="token string">"gulp-uglify"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> //js压缩组件var htmlmin <span class="token operator">=</span> require<span class="token punctuation">(</span><span class="token string">"gulp-htmlmin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> //html压缩组件var htmlclean <span class="token operator">=</span> require<span class="token punctuation">(</span><span class="token string">"gulp-htmlclean"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> //html清理组件var changed <span class="token operator">=</span> require<span class="token punctuation">(</span><span class="token string">"gulp-changed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> //文件更改校验组件var gulpif <span class="token operator">=</span> require<span class="token punctuation">(</span><span class="token string">"gulp-if"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> //任务 帮助调用组件var plumber <span class="token operator">=</span> require<span class="token punctuation">(</span><span class="token string">"gulp-plumber"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> //容错组件（发生错误不跳出任务，并报出错误内容）var isScriptAll <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> //是否处理所有文件，<span class="token punctuation">(</span>true<span class="token operator">|</span>处理所有文件<span class="token punctuation">)</span><span class="token punctuation">(</span>false<span class="token operator">|</span>只处理有更改的文件<span class="token punctuation">)</span>var isDebug <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> //是否调试显示 编译通过的文件var gulpBabel <span class="token operator">=</span> require<span class="token punctuation">(</span><span class="token string">"gulp-babel"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>var es2015Preset <span class="token operator">=</span> require<span class="token punctuation">(</span><span class="token string">"babel-preset-es2015"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>var del <span class="token operator">=</span> require<span class="token punctuation">(</span><span class="token string">"del"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>var Hexo <span class="token operator">=</span> require<span class="token punctuation">(</span><span class="token string">"hexo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>var hexo <span class="token operator">=</span> new Hexo<span class="token punctuation">(</span>process.cwd<span class="token punctuation">(</span><span class="token punctuation">)</span>, <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> // 初始化一个hexo对象// hexo cleangulp.task<span class="token punctuation">(</span><span class="token string">"clean"</span>, <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> del<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"public/**/*"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>// hexo generategulp.task<span class="token punctuation">(</span><span class="token string">"generate"</span>, <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> hexo.init<span class="token punctuation">(</span><span class="token punctuation">)</span>.then<span class="token punctuation">(</span>function <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> hexo            .call<span class="token punctuation">(</span><span class="token string">"generate"</span>, <span class="token punctuation">{</span>                watch: <span class="token boolean">false</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>            .then<span class="token punctuation">(</span>function <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> hexo.exit<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>            .catch<span class="token punctuation">(</span>function <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> hexo.exit<span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>// Hexo sgulp.task<span class="token punctuation">(</span><span class="token string">"server"</span>, <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> hexo        .init<span class="token punctuation">(</span><span class="token punctuation">)</span>        .then<span class="token punctuation">(</span>function <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> hexo.call<span class="token punctuation">(</span><span class="token string">"server"</span>, <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        .catch<span class="token punctuation">(</span>function <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>            console.log<span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>// 压缩public目录下的js文件gulp.task<span class="token punctuation">(</span><span class="token string">"compressJs"</span>, <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> gulp        .src<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"./public/**/*.js"</span>, <span class="token string">"!./public/libs/**"</span><span class="token punctuation">]</span><span class="token punctuation">)</span> //排除的js        .pipe<span class="token punctuation">(</span>gulpif<span class="token punctuation">(</span><span class="token operator">!</span>isScriptAll, changed<span class="token punctuation">(</span><span class="token string">"./public"</span><span class="token punctuation">))</span><span class="token punctuation">)</span>        .pipe<span class="token punctuation">(</span>gulpif<span class="token punctuation">(</span>isDebug, debug<span class="token punctuation">(</span><span class="token punctuation">{</span> title: <span class="token string">"Compress JS:"</span> <span class="token punctuation">}</span><span class="token punctuation">))</span><span class="token punctuation">)</span>        .pipe<span class="token punctuation">(</span>plumber<span class="token punctuation">(</span><span class="token punctuation">))</span>        .pipe<span class="token punctuation">(</span>            gulpBabel<span class="token punctuation">(</span><span class="token punctuation">{</span>                presets: <span class="token punctuation">[</span>es2015Preset<span class="token punctuation">]</span> // es5检查机制            <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">)</span>        .pipe<span class="token punctuation">(</span>uglify<span class="token punctuation">(</span><span class="token punctuation">))</span> //调用压缩组件方法uglify<span class="token punctuation">(</span><span class="token punctuation">)</span>,对合并的文件进行压缩        .pipe<span class="token punctuation">(</span>gulp.dest<span class="token punctuation">(</span><span class="token string">"./public"</span><span class="token punctuation">))</span><span class="token punctuation">;</span> //输出到目标目录<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>// 压缩public目录下的css文件gulp.task<span class="token punctuation">(</span><span class="token string">"compressCss"</span>, <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    var option <span class="token operator">=</span> <span class="token punctuation">{</span>        rebase: false,        //advanced: true, //类型：Boolean 默认：true <span class="token punctuation">[</span>是否开启高级优化（合并选择器等）<span class="token punctuation">]</span>        compatibility: <span class="token string">"ie7"</span> //保留ie7及以下兼容写法 类型：String 默认：<span class="token string">''</span>or<span class="token string">'*'</span> <span class="token punctuation">[</span>启用兼容模式； <span class="token string">'ie7'</span>：IE7兼容模式，<span class="token string">'ie8'</span>：IE8兼容模式，<span class="token string">'*'</span>：IE9+兼容模式<span class="token punctuation">]</span>        //keepBreaks: true, //类型：Boolean 默认：false <span class="token punctuation">[</span>是否保留换行<span class="token punctuation">]</span>        //keepSpecialComments: <span class="token string">'*'</span> //保留所有特殊前缀 当你用autoprefixer生成的浏览器前缀，如果不加这个参数，有可能将会删除你的部分前缀    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> gulp        .src<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"./public/**/*.css"</span>, <span class="token string">"!./public/**/*.min.css"</span><span class="token punctuation">]</span><span class="token punctuation">)</span> //排除的css        .pipe<span class="token punctuation">(</span>gulpif<span class="token punctuation">(</span><span class="token operator">!</span>isScriptAll, changed<span class="token punctuation">(</span><span class="token string">"./public"</span><span class="token punctuation">))</span><span class="token punctuation">)</span>        .pipe<span class="token punctuation">(</span>gulpif<span class="token punctuation">(</span>isDebug, debug<span class="token punctuation">(</span><span class="token punctuation">{</span> title: <span class="token string">"Compress CSS:"</span> <span class="token punctuation">}</span><span class="token punctuation">))</span><span class="token punctuation">)</span>        .pipe<span class="token punctuation">(</span>plumber<span class="token punctuation">(</span><span class="token punctuation">))</span>        .pipe<span class="token punctuation">(</span>cleancss<span class="token punctuation">(</span>option<span class="token punctuation">))</span>        .pipe<span class="token punctuation">(</span>gulp.dest<span class="token punctuation">(</span><span class="token string">"./public"</span><span class="token punctuation">))</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>// 压缩public目录下的html文件gulp.task<span class="token punctuation">(</span><span class="token string">"compressHtml"</span>, <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    var cleanOptions <span class="token operator">=</span> <span class="token punctuation">{</span>        protect: /<span class="token operator">&lt;</span>\<span class="token operator">!</span>--%fooTemplate\b.*?%--<span class="token operator">></span>/g, //忽略处理        unprotect: /<span class="token operator">&lt;</span>script <span class="token punctuation">[</span>^<span class="token operator">></span><span class="token punctuation">]</span>*\btype<span class="token operator">=</span><span class="token string">"text\/x-handlebars-template"</span><span class="token punctuation">[</span>\s\S<span class="token punctuation">]</span>+?<span class="token operator">&lt;</span>\/script<span class="token operator">></span>/gi //特殊处理    <span class="token punctuation">}</span><span class="token punctuation">;</span>    var minOption <span class="token operator">=</span> <span class="token punctuation">{</span>        collapseWhitespace: true, //压缩HTML        collapseBooleanAttributes: true, //省略布尔属性的值 <span class="token operator">&lt;</span>input checked<span class="token operator">=</span><span class="token string">"true"</span>/<span class="token operator">></span> <span class="token operator">==</span><span class="token operator">></span> <span class="token operator">&lt;</span>input /<span class="token operator">></span>        removeEmptyAttributes: true, //删除所有空格作属性值 <span class="token operator">&lt;</span>input id<span class="token operator">=</span><span class="token string">""</span> /<span class="token operator">></span> <span class="token operator">==</span><span class="token operator">></span> <span class="token operator">&lt;</span>input /<span class="token operator">></span>        removeScriptTypeAttributes: true, //删除<span class="token operator">&lt;</span>script<span class="token operator">></span>的type<span class="token operator">=</span><span class="token string">"text/javascript"</span>        removeStyleLinkTypeAttributes: true, //删除<span class="token operator">&lt;</span>style<span class="token operator">></span>和<span class="token operator">&lt;</span>link<span class="token operator">></span>的type<span class="token operator">=</span><span class="token string">"text/css"</span>        removeComments: true, //清除HTML注释        minifyJS: true, //压缩页面JS        minifyCSS: true, //压缩页面CSS        minifyURLs: <span class="token boolean">true</span> //替换页面URL    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> gulp        .src<span class="token punctuation">(</span><span class="token string">"./public/**/*.html"</span><span class="token punctuation">)</span>        .pipe<span class="token punctuation">(</span>gulpif<span class="token punctuation">(</span>isDebug, debug<span class="token punctuation">(</span><span class="token punctuation">{</span> title: <span class="token string">"Compress HTML:"</span> <span class="token punctuation">}</span><span class="token punctuation">))</span><span class="token punctuation">)</span>        .pipe<span class="token punctuation">(</span>plumber<span class="token punctuation">(</span><span class="token punctuation">))</span>        .pipe<span class="token punctuation">(</span>htmlclean<span class="token punctuation">(</span>cleanOptions<span class="token punctuation">))</span>        .pipe<span class="token punctuation">(</span>htmlmin<span class="token punctuation">(</span>minOption<span class="token punctuation">))</span>        .pipe<span class="token punctuation">(</span>gulp.dest<span class="token punctuation">(</span><span class="token string">"./public"</span><span class="token punctuation">))</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>// 默认任务gulp.task<span class="token punctuation">(</span>    <span class="token string">"default"</span>,    gulp.series<span class="token punctuation">(</span>        <span class="token string">"clean"</span>,        <span class="token string">"generate"</span>,        gulp.parallel<span class="token punctuation">(</span><span class="token string">"compressHtml"</span>, <span class="token string">"compressCss"</span>, <span class="token string">"compressJs"</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>根目录下执行 <code>gulp</code> 就相当于<code>hexo clean &amp;&amp; hexo g</code>，再把代码压缩。</p><p>再使用 <code>hexo d</code>即可部署到 Github</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
